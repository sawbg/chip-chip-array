{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment ChipChipArray }ChipChipArray}
{\comment Generated byDoxgyen. }
{\creatim \yr2016\mo4\dy22\hr16\min3\sec30}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b ChipChipArray} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Adafruit_PWMServoDriver} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ChipChipArray::Arm} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ChipChipArray::Block} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ChipChipArray::Grabber} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ChipChipArray::Log} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ChipChipArray::PiCamera} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b makefile} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Project makefile containing recipes for compiling the actual application, test applications, and generating documentation })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b etc/{\b doxygen.config} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Doxygen configuration file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Adafruit_PWMServoDriver.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the function and class definitions necessary for the PWM servo driver })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Adafruit_PWMServoDriver.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Arm.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the Arm class used to control the robotic arm })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Block.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains Block class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b cv_hue.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains program formally used to find HSV values for blocks })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b cv_shape.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to aid in determining HSV ranges })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b cv_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains program used to test PiCamera class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b dark_magic.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test code for arm })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b definitions.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains definitions for architecture-independant numeric variables, enumerations and enumerated classes, and #define'd constants, and to_sting() overloads for the enumerated classes })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Grabber.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the Grabber class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b img.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to display the current camera image })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b jacob_alg_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program that tests Jacob's yellow-detection algorithm })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b loading_test.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Log.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains Log class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b log_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to test partially the Log class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b main.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the {\b main()} function to the whole project })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b NavigationControl.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the navigation control function definitions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b NavigationControl.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the function definitions for navigation control })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b net_qr_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test program for reading QR codes })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b old_cv_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains old test program for the RaspiCam_Cv class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b PiCamera.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains PiCamera class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b qr_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test program for {\b ScanQR()} function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b ScanQR.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains {\b ScanQR()} function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Servo_Position_Shell.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
COntains the function definitions for the servo position shell })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAES \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Servo_Position_Shell.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the function prototypes for the servo position shell })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChipChipArray Namespace Reference\par \pard\plain 
{\tc\tcl2 \v ChipChipArray}
{\xe \v ChipChipArray}
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Arm}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Block}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Grabber}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Log}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PiCamera}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Color} {\b ScanQR} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8} {\b qrInvokeCount} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Log} {\b scanQrLog} ("logs/{\b ScanQR}", LogMode::Multi)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:ChipChipArray}
{\xe \v ChipChipArray\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ChipChipArray::main (int {\i argc}, char ** {\i argv})}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program was used before {\b cv_shape.cpp} was written to find HSV ranges for the different color blocks. This is a slightly modified version of some code written by Shermal Fernando in the blog post "Color Detection & Object Tracking" at {\f2 http://opencv-srf.blogspot.com/2010/09/object-detection-using-color-seperation.html}". \par
}{
Definition at line 27 of file cv_hue.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27                                       \{\par
28         PiCamera cam;\par
29         namedWindow("Control", CV_WINDOW_AUTOSIZE); //create a window called "Control"\par
30 \par
31         int iLowH = 170;\par
32         int iHighH = 179;\par
33 \par
34         int iLowS = 150; \par
35         int iHighS = 255;\par
36 \par
37         int iLowV = 60;\par
38         int iHighV = 255;\par
39 \par
40         //Create trackbars in "Control" window\par
41         createTrackbar("LowH", "Control", &iLowH, 179); //Hue (0 - 179)\par
42         createTrackbar("HighH", "Control", &iHighH, 179);\par
43 \par
44         createTrackbar("LowS", "Control", &iLowS, 255); //Saturation (0 - 255)\par
45         createTrackbar("HighS", "Control", &iHighS, 255);\par
46 \par
47         createTrackbar("LowV", "Control", &iLowV, 255);//Value (0 - 255)\par
48         createTrackbar("HighV", "Control", &iHighV, 255);\par
49 \par
50         int iLastX = -1; \par
51         int iLastY = -1;\par
52 \par
53         //Capture a temporary image from the camera\par
54         Mat imgTmp = cam.Snap();\par
55 \par
56         //Create a black image with the size as the camera output\par
57         Mat imgLines = Mat::zeros( imgTmp.size(), CV_8UC3 );;\par
58 \par
59 \par
60         while (true)\par
61         \{\par
62             Mat imgOriginal = cam.Snap(); // read a new frame from video\par
63             Mat imgHSV;\par
64 \par
65             cvtColor(imgOriginal, imgHSV, COLOR_BGR2HSV); //Convert the captured frame from BGR to HSV\par
66 \par
67             Mat imgThresholded;\par
68 \par
69             inRange(imgHSV, Scalar(iLowH, iLowS, iLowV), Scalar(iHighH, iHighS, iHighV), imgThresholded); //Threshold the image\par
70 \par
71             //morphological opening (removes small objects from the foreground)\par
72             erode(imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) );\par
73             dilate( imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) ); \par
74 \par
75             //morphological closing (removes small holes from the foreground)\par
76             dilate( imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) ); \par
77             erode(imgThresholded, imgThresholded, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) );\par
78 \par
79             //Calculate the moments of the thresholded image\par
80             Moments oMoments = moments(imgThresholded);\par
81 \par
82             /*double dM01 = oMoments.m01;\par
83               double dM10 = oMoments.m10;\par
84               double dArea = oMoments.m00;\par
85 \par
86             // if the area <= 10000, I consider that the there are no object in the image and it's because of the noise, the area is not zero \par
87             if (dArea > 50000)\par
88             \{\par
89             //calculate the position of the ball\par
90             int posX = dM10 / dArea;\par
91             int posY = dM01 / dArea;        \par
92 \par
93             if (iLastX >= 0 && iLastY >= 0 && posX >= 0 && posY >= 0)\par
94             \{\par
95             //Draw a red line from the previous point to the current point\par
96             line(imgLines, Point(posX, posY), Point(iLastX, iLastY), Scalar(0,0,255), 2);\par
97             \}\par
98 \par
99             iLastX = posX;\par
100             iLastY = posY;\par
101             \}\par
102             */\par
103             imshow("Thresholded Image", imgThresholded); //show the thresholded image\par
104 \par
105             //      imgOriginal = imgOriginal + imgLines;\par
106             imshow("Original", imgOriginal); //show the original image\par
107 \par
108             if (waitKey(30) == 27) //wait for 'esc' key press for 30ms. If 'esc' key is pressed, break loop\par
109             \{\par
110                 cout << "esc key is pressed by user" << endl;\par
111                 break; \par
112             \}\par
113         \}\par
114 \par
115         return 0;\par
116     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceChipChipArray_a7fc3d1edffca11531cd09fdab7c8b88d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v ScanQR\:ChipChipArray}
{\xe \v ChipChipArray\:ScanQR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Color} ChipChipArray::ScanQR ()}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function manuvers arm to look at the QR code on a train car as the robot is backing up to the car. It attempts to find the code in multiple images before finally throwing an exeption if a code is not found. If multiple codes are found, it returns a single Color by (seemingly) arbitrary decision.\par
This function is based on code written by Michael Young ({\f2 https://github.com/ayoungprogrammer/WebcamCodeScanner}). \par
}{
Definition at line 41 of file ScanQR.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41                    \{\par
42         // 0. Initialize variables\par
43         Color color;\par
44         PiCamera cam(false);\par
45 \par
46         // 1. Position arm\par
47         scanQrLog.Verbose("Positioning arm");\par
48 \par
49         // 2. Scan images from camera\par
50         scanQrLog.Verbose("Scanning for QR code");\par
51 \par
52         // Nick's supposed to make sure this isn't an endles loop\par
53         while(true) \{           \par
54             // get image\par
55             cv::Mat frame = cam.Snap();\par
56             cv::Mat canvas;\par
57             cv::cvtColor(frame, canvas, CV_BGR2GRAY);\par
58             scanQrLog.Image(canvas, std::to_string(++qrInvokeCount)\par
59                     + ".bmp");\par
60             \par
61             uint32 width = canvas.cols;\par
62             uint32 height = canvas.rows;\par
63             zbar::Image image(width, height, "Y800",\par
64                     (uchar*)canvas.data, width * height);\par
65 \par
66             zbar::ImageScanner scanner;\par
67             scanner.set_config(zbar::ZBAR_NONE, zbar::ZBAR_CFG_ENABLE, 1);\par
68             scanner.scan(image);\par
69             zbar::Image::SymbolIterator symbol = image.symbol_begin();\par
70 \par
71             if(symbol != image.symbol_end()) \{\par
72                 switch(symbol->get_data()[0]) \{\par
73                     case 'r':\par
74                         color = Color::Red;\par
75                         break;\par
76 \par
77                     case 'y':\par
78                         color = Color::Yellow;\par
79                         break;\par
80 \par
81                     case 'g':\par
82                         color = Color::Green;\par
83                         break;\par
84 \par
85                     case 'b':\par
86                         color = Color::Blue;\par
87                         break;\par
88                 \}\par
89 \par
90                 scanQrLog.Status("Detected " + std::to_string(color)\par
91                         + " train car");\par
92                 break;\par
93             \}\par
94         \}\par
95 \par
96         // 3. Retract arm\par
97         scanQrLog.Verbose("Retracting arm");        \par
98         return color;\par
99     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceChipChipArray_a6c7465049b5d408e1a238b6d8ffa887d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceChipChipArray_a6c7465049b5d408e1a238b6d8ffa887d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v qrInvokeCount\:ChipChipArray}
{\xe \v ChipChipArray\:qrInvokeCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8} ChipChipArray::qrInvokeCount = 0}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of times {\b ScanQR()} has been called. Used for ScanQR log. \par
}{
Definition at line 24 of file ScanQR.hpp.}\par
}
{\xe \v scanQrLog\:ChipChipArray}
{\xe \v ChipChipArray\:scanQrLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Log} ChipChipArray::scanQrLog("logs/{\b ScanQR}", LogMode::Multi)}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Log} instance used by the {\b ScanQR()} function. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std Namespace Reference\par \pard\plain 
{\tc\tcl2 \v std}
{\xe \v std}
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b to_string} ({\b BlockPosition} pos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b to_string} ({\b Color} color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b to_string} ({\b LogMode} mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b to_string} ({\b Result} res)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b to_string} ({\b Side} side)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b to_string} ({\b Size} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b to_string} ({\b Zone} zone)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v to_string\:std}
{\xe \v std\:to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string std::to_string ({\b BlockPosition} {\i pos})}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a BlockPosition to a string. \par
}{
Definition at line 107 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 107                                         \{\par
108         if(pos == BlockPosition::Front) return string("Front");\par
109         else return string("Back");\par
110     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespacestd_aa5ddf582a1c96ffe258c997be9a294a3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v to_string\:std}
{\xe \v std\:to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string std::to_string ({\b Color} {\i color})}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a Color to a string. \par
}{
Definition at line 115 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 115                                   \{\par
116         string ret;\par
117 \par
118         switch((ENUM)color) \{\par
119             case 0:\par
120                 ret = "Red";\par
121                 break;\par
122 \par
123             case 1:\par
124                 ret = "Yellow";\par
125                 break;\par
126 \par
127             case 2:\par
128                 ret = "Green";\par
129                 break;\par
130 \par
131             case 3:\par
132                 ret = "Blue";\par
133                 break;\par
134 \par
135             case 4:\par
136                 ret = "All";\par
137                 break;\par
138         \}\par
139 \par
140         return ret;\par
141     \}\par
}
}
{\xe \v to_string\:std}
{\xe \v std\:to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string std::to_string ({\b LogMode} {\i mode})}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a LogMode to a string. \par
}{
Definition at line 146 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 146                                    \{\par
147         if(mode == LogMode::Multi) return string("Text");\par
148         else return string("Multi");\par
149     \}\par
}
}
{\xe \v to_string\:std}
{\xe \v std\:to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string std::to_string ({\b Result} {\i res})}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a Result to a string. \par
}{
Definition at line 154 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 154                                  \{\par
155         string ret;\par
156 \par
157         switch((ENUM)res) \{\par
158             case -1:\par
159                 ret = "No Blocks";\par
160                 break;\par
161 \par
162             case 0:\par
163                 ret = "Two whole, no halves";\par
164                 break;\par
165 \par
166             case 2:\par
167                 ret = "Two whole, two halves";\par
168                 break;\par
169 \par
170             case 4:\par
171                 ret = "No whole, four halves";\par
172                 break;\par
173         \}\par
174 \par
175         return ret;\par
176     \}\par
}
}
{\xe \v to_string\:std}
{\xe \v std\:to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string std::to_string ({\b Side} {\i side})}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a Side to a string. \par
}{
Definition at line 181 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 181                                 \{\par
182         if(side == Side::Left) return string("Left");\par
183         else return string("Right");\par
184     \}\par
}
}
{\xe \v to_string\:std}
{\xe \v std\:to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string std::to_string ({\b Size} {\i size})}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a Size to a string. \par
}{
Definition at line 189 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 189                                 \{\par
190         if(size == Size::Long) return string("Long");\par
191         else return string("Short");\par
192     \}\par
}
}
{\xe \v to_string\:std}
{\xe \v std\:to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string std::to_string ({\b Zone} {\i zone})}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a Zone to a string. \par
}{
Definition at line 197 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 197                                 \{\par
198         return string(1, (char)zone);\par
199     \}\par
}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Adafruit_PWMServoDriver Class Reference\par \pard\plain 
{\tc\tcl2 \v Adafruit_PWMServoDriver}
{\xe \v Adafruit_PWMServoDriver}
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
\par
{
{\f2 #include <Adafruit_PWMServoDriver.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Adafruit_PWMServoDriver} ({\b uint8_t} addr=0x41)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b begin} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPWMFreq} (float freq)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPWM} ({\b uint8_t} num, {\b uint16_t} on, {\b uint16_t} off)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPin} ({\b uint8_t} num, {\b uint16_t} val, bool invert=false)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 73 of file Adafruit_PWMServoDriver.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Adafruit_PWMServoDriver\:Adafruit_PWMServoDriver}
{\xe \v Adafruit_PWMServoDriver\:Adafruit_PWMServoDriver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Adafruit_PWMServoDriver::Adafruit_PWMServoDriver ({\b uint8_t} {\i addr} = {\f2 0x41})}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file Adafruit_PWMServoDriver.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 37                                                              \{\par
38     _i2caddr = addr;\par
39     _i2cFD = -1;\par
40 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:Adafruit_PWMServoDriver}
{\xe \v Adafruit_PWMServoDriver\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Adafruit_PWMServoDriver::begin (void )}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file Adafruit_PWMServoDriver.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42                                         \{\par
43     _i2cFD = wiringPiI2CSetup(_i2caddr);\par
44     if (_i2cFD < 0) \{\par
45         //FIXME: error occurred\par
46     \}\par
47     reset();\par
48 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classAdafruit__PWMServoDriver_aef401eaad3c34222ac916eb7bd936bc2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classAdafruit__PWMServoDriver_aef401eaad3c34222ac916eb7bd936bc2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v reset\:Adafruit_PWMServoDriver}
{\xe \v Adafruit_PWMServoDriver\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Adafruit_PWMServoDriver::reset (void )}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 50 of file Adafruit_PWMServoDriver.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50                                         \{\par
51     write8(PCA9685_MODE1, 0x0);\par
52 \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classAdafruit__PWMServoDriver_ac976f52233a75a4bd0eb6f2ce9b82b7f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v setPin\:Adafruit_PWMServoDriver}
{\xe \v Adafruit_PWMServoDriver\:setPin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Adafruit_PWMServoDriver::setPin ({\b uint8_t} {\i num}, {\b uint16_t} {\i val}, bool {\i invert} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 116 of file Adafruit_PWMServoDriver.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 116                                                                            \{\par
117     // Clamp value between 0 and 4095 inclusive.\par
118     val = min(val, (uint16_t)4095);\par
119     if (invert) \{\par
120         if (val == 0) \{\par
121             // Special value for signal fully on.\par
122             setPWM(num, 4096, 0);\par
123         \} else if (val == 4095) \{\par
124             // Special value for signal fully off.\par
125             setPWM(num, 0, 4096);\par
126         \} else \{\par
127             setPWM(num, 0, 4095 - val);\par
128         \}\par
129     \} else \{\par
130         if (val == 4095) \{\par
131             // Special value for signal fully on.\par
132             setPWM(num, 4096, 0);\par
133         \} else if (val == 0) \{\par
134             // Special value for signal fully off.\par
135             setPWM(num, 0, 4096);\par
136         \} else \{\par
137             setPWM(num, 0, val);\par
138         \}\par
139     \}\par
140 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classAdafruit__PWMServoDriver_a1246cd50849fe0f068cc5d474e06ae96_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v setPWM\:Adafruit_PWMServoDriver}
{\xe \v Adafruit_PWMServoDriver\:setPWM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Adafruit_PWMServoDriver::setPWM ({\b uint8_t} {\i num}, {\b uint16_t} {\i on}, {\b uint16_t} {\i off})}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file Adafruit_PWMServoDriver.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 81                                                                            \{\par
82     //Serial.print("Setting PWM "); Serial.print(num); Serial.print(": "); Serial.print(on); Serial.print("->"); Serial.println(off);\par
83 \par
84     int result = wiringPiI2CWriteReg16(_i2cFD, LED0_ON_L + 4 * num, on);\par
85     if (result < 0) \{\par
86         string s(strerror(errno));\par
87         cout << "setPWM error: " << s.c_str() << endl;\par
88     \}\par
89 //    result = wiringPiI2CWrite(_i2cFD, on);\par
90 //    if (result < 0) \{\par
91 //        string s(strerror(errno));\par
92 //        cout << "setPWM error: " << s.c_str() << endl;\par
93 //    \}\par
94 //    result = wiringPiI2CWrite(_i2cFD, on >> 8);\par
95 //    if (result < 0) \{\par
96 //        string s(strerror(errno));\par
97 //        cout << "setPWM error: " << s.c_str() << endl;\par
98 //    \}\par
99     result = wiringPiI2CWriteReg16(_i2cFD, LED0_OFF_L + 4 * num, off);\par
100 //    result = wiringPiI2CWrite(_i2cFD, off);\par
101     if (result < 0) \{\par
102         string s(strerror(errno));\par
103         cout << "setPWM error: " << s.c_str() << endl;\par
104     \}\par
105 //    result = wiringPiI2CWrite(_i2cFD, off >> 8);\par
106 //    if (result < 0) \{\par
107 //        string s(strerror(errno));\par
108 //        cout << "setPWM error: " << s.c_str() << endl;\par
109 //    \}\par
110 \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classAdafruit__PWMServoDriver_a724a7fc39c6fba34478ecc0eea038bd3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v setPWMFreq\:Adafruit_PWMServoDriver}
{\xe \v Adafruit_PWMServoDriver\:setPWMFreq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Adafruit_PWMServoDriver::setPWMFreq (float {\i freq})}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file Adafruit_PWMServoDriver.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 54                                                    \{\par
55     //Serial.print("Attempting to set freq ");\par
56     //Serial.println(freq);\par
57     freq *= 0.9; // Correct for overshoot in the frequency setting (see issue #11).\par
58     float prescaleval = 25000000;\par
59     prescaleval /= 4096;\par
60     prescaleval /= freq;\par
61     prescaleval -= 1;\par
62     if (ENABLE_DEBUG_OUTPUT) \{\par
63         cout << "Estimated pre-scale: " << prescaleval << endl;\par
64     \}\par
65     uint8_t prescale = floor(prescaleval + 0.5);\par
66     if (ENABLE_DEBUG_OUTPUT) \{\par
67         cout << "Final pre-scale: " << prescale << endl;\par
68     \}\par
69 \par
70     uint8_t oldmode = read8(PCA9685_MODE1);\par
71     uint8_t newmode = (oldmode & 0x7F) | 0x10; // sleep\par
72     write8(PCA9685_MODE1, newmode); // go to sleep\par
73     write8(PCA9685_PRESCALE, prescale); // set the prescaler\par
74     write8(PCA9685_MODE1, oldmode);\par
75     usleep(5000);\par
76     write8(PCA9685_MODE1, oldmode | 0xa1); //  This sets the MODE1 register to turn on auto increment.\par
77     // This is why the beginTransmission below was not working.\par
78     //  Serial.print("Mode now 0x"); Serial.println(read8(PCA9685_MODE1), HEX);\par
79 \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classAdafruit__PWMServoDriver_a0ef6f1e3c81aebbd1d1da1bb12f3ed5c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b Adafruit_PWMServoDriver.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b Adafruit_PWMServoDriver.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChipChipArray::Arm Class Reference\par \pard\plain 
{\tc\tcl2 \v ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm}
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
\par
{
{\f2 #include <Arm.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Arm} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BaseTilt} ({\b uint8} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BaseTurn} ({\b uint8} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClawOpen} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClawClose} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dBaseTilt} ({\b sint16} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dBaseTurn} ({\b sint16} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dElbow} ({\b sint16} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dWristTilt} ({\b sint16} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dWristTwist} ({\b sint16} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Elbow} ({\b uint8} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Hover} ({\b Zone} zone)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WristTilt} ({\b uint8} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WristTwist} ({\b uint8} a)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8} {\b servoPos} [7] = \{ 0, 0, 0, 0, 0, 0, 0 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dLeftGripper} ({\b sint16} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dRightGripper} ({\b sint16} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b LeftGripper} ({\b uint8} a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RightGripper} ({\b uint8} a)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class provides a layer of abstraction from the existing servo interface. It is designed to make more sense programmatically and to be easier to use. \par
}{
Definition at line 23 of file Arm.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Arm\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:Arm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ChipChipArray::Arm::Arm ()}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the I2C interface for the arm if another instance of the {\b Arm} class has not already. \par
}{
Definition at line 173 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 173              \{\par
174         if(!init) \{\par
175             setup();\par
176             init = true;\par
177         \}\par
178     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_aeda43d8461e50eaca9aa891ee2863c05_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v BaseTilt\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:BaseTilt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::BaseTilt ({\b uint8} {\i a})}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tilts the base of the arm.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i a} \cell }{desired servo position in degrees \cell }
{\row }
}
}{
Definition at line 180 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 180                               \{\par
181         setServoPosition(BASE_TILT, a);\par
182         servoPos[BASE_TILT] = a;\par
183     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a8b077a3791d9fc5ef285c1520fe4c5d8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a8b077a3791d9fc5ef285c1520fe4c5d8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v BaseTurn\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:BaseTurn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::BaseTurn ({\b uint8} {\i a})}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Twists the entire arm.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i a} \cell }{desired servo position in degrees \cell }
{\row }
}
}{
Definition at line 185 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 185                               \{\par
186         setServoPosition(BASE_TURN, a);\par
187         servoPos[BASE_TURN] = a;\par
188     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_addaedfe85ff2b14ff00c344fc4b40cd6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_addaedfe85ff2b14ff00c344fc4b40cd6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v ClawClose\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:ClawClose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::ClawClose ()}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Closes the claw enough to hold a block in place during movement but does not attempt to completely close the claw in order ot prevent unnecessary strain on the servos. \par
}{
Definition at line 195 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 195                         \{\par
196         LeftGripper(180);\par
197         RightGripper(0);\par
198     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a20c6fe3fe79c16f492a8c18b91427080_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a20c6fe3fe79c16f492a8c18b91427080_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v ClawOpen\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:ClawOpen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::ClawOpen ()}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Opens the claw completely (within safe limits). \par
}{
Definition at line 190 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 190                        \{\par
191         LeftGripper(0);\par
192         RightGripper(180);\par
193     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_abb33b5bb11034554d632f8c9b95b2c44_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_abb33b5bb11034554d632f8c9b95b2c44_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v dBaseTilt\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:dBaseTilt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::dBaseTilt ({\b sint16} {\i a})}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tilts the base a certain number of degrees.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i degrees} \cell }{to move servo. Positive values add to the servo angle, and negative values subtract from the servo angle. \cell }
{\row }
}
}{
Definition at line 200 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 200                                 \{\par
201         a += servoPos[BASE_TILT];\par
202         setServoPosition(BASE_TILT, a);\par
203         servoPos[BASE_TILT] = a;\par
204     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_af84b91c664baec0f2882dcf4089ae027_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v dBaseTurn\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:dBaseTurn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::dBaseTurn ({\b sint16} {\i a})}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Turn the base a certain number of degrees.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i degrees} \cell }{to move servo. Positive values add to the servo angle, and negative values subtract from the servo angle. \cell }
{\row }
}
}{
Definition at line 206 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 206                                 \{\par
207         a += servoPos[BASE_TURN];\par
208         setServoPosition(BASE_TURN, a);\par
209         servoPos[BASE_TURN] = a;\par
210     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a980f5bd278cbe06aa21754fb8e0324b3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a980f5bd278cbe06aa21754fb8e0324b3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v dElbow\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:dElbow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::dElbow ({\b sint16} {\i a})}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bend the elbow a certain number of degrees.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i degrees} \cell }{to move servo. Positive values add to the servo angle, and negative values subtract from the servo angle. \cell }
{\row }
}
}{
Definition at line 212 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 212                              \{\par
213         a += servoPos[ELBOW];\par
214         setServoPosition(ELBOW, a);\par
215         servoPos[ELBOW] = a;\par
216     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_ae8d0a664dd1a0e556cf40c0984035163_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v dLeftGripper\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:dLeftGripper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::dLeftGripper ({\b sint16} {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves the left gripper servo a certain number of degrees.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i degrees} \cell }{to move servo. Positive values add to the servo angle, and negative values subtract from the servo angle. \cell }
{\row }
}
}{
Definition at line 218 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 218                                    \{\par
219         a += servoPos[GRIP_LEFT];\par
220         setServoPosition(GRIP_LEFT, a);\par
221         servoPos[GRIP_LEFT] = a;\par
222     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a6da0950c7e3bd4a31264e562916c032d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v dRightGripper\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:dRightGripper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::dRightGripper ({\b sint16} {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves the right gripper servo a certain number of degrees.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i degrees} \cell }{to move servo. Positive values add to the servo angle, and negative values subtract from the servo angle. \cell }
{\row }
}
}{
Definition at line 224 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 224                                     \{\par
225         a += servoPos[GRIP_RIGHT];\par
226         setServoPosition(GRIP_RIGHT, a);\par
227         servoPos[GRIP_RIGHT] = a;\par
228     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_adfa7cc779b7ec3bf8453277796c142ed_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v dWristTilt\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:dWristTilt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::dWristTilt ({\b sint16} {\i a})}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tilt the wrist a certain number of degrees.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i degrees} \cell }{to move servo. Positive values add to the servo angle, and negative values subtract from the servo angle. \cell }
{\row }
}
}{
Definition at line 230 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 230                                  \{\par
231         a += servoPos[WRIST_TILT];\par
232         setServoPosition(WRIST_TILT, a);\par
233         servoPos[WRIST_TILT] = a;\par
234     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a43daba698f13a522887ad022b78557bb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v dWristTwist\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:dWristTwist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::dWristTwist ({\b sint16} {\i a})}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Twist the wrist a certain number of degrees.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i degrees} \cell }{to move servo. Positive values add to the servo angle, and negative values subtract from the servo angle. \cell }
{\row }
}
}{
Definition at line 236 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 236                                   \{\par
237         a += servoPos[WRIST_TWIST];\par
238         setServoPosition(WRIST_TWIST, a);\par
239         servoPos[WRIST_TWIST] = a;\par
240     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a6bde822b1be63926e21222f36aad67b3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a6bde822b1be63926e21222f36aad67b3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Elbow\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:Elbow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::Elbow ({\b uint8} {\i a})}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bend the elbow to a specific position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i a} \cell }{desired servo position in degrees \cell }
{\row }
}
}{
Definition at line 242 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 242                            \{\par
243         setServoPosition(ELBOW, a);\par
244         servoPos[ELBOW] = a;\par
245     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_ac45149e03abfac230b75156bb42e8417_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_ac45149e03abfac230b75156bb42e8417_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Hover\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:Hover}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::Hover ({\b Zone} {\i zone})}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves arm into its "hovering" position over the blocks. The position changes with the zone.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i zone} \cell }{the zone for which the arm should position itself \cell }
{\row }
}
}}
{\xe \v LeftGripper\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:LeftGripper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::LeftGripper ({\b uint8} {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves the left gripper to a specific position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i a} \cell }{desired servo position in degrees \cell }
{\row }
}
}{
Definition at line 247 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 247                                  \{\par
248         setServoPosition(GRIP_LEFT, a);\par
249         servoPos[GRIP_LEFT] = a;\par
250     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a776eade3a7aaa6effaabad7f37c71031_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a776eade3a7aaa6effaabad7f37c71031_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v RightGripper\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:RightGripper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::RightGripper ({\b uint8} {\i a}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves the right gripper to a specific position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i a} \cell }{desired servo position in degrees \cell }
{\row }
}
}{
Definition at line 252 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 252                                   \{\par
253         setServoPosition(GRIP_RIGHT, a);\par
254         servoPos[GRIP_RIGHT] = a;\par
255     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a46a0b0cfb37cb0b663c91cd07e440e10_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a46a0b0cfb37cb0b663c91cd07e440e10_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v WristTilt\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:WristTilt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::WristTilt ({\b uint8} {\i a})}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tilt the wrist to a specific position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i a} \cell }{desired servo position in degrees \cell }
{\row }
}
}{
Definition at line 257 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 257                                \{\par
258         setServoPosition(WRIST_TILT, a);\par
259         servoPos[WRIST_TILT] = a;\par
260     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_ad61f7c1e63eb09981b6c304bd924e217_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v WristTwist\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:WristTwist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Arm::WristTwist ({\b uint8} {\i a})}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Twist the wrist to a specific position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i a} \cell }{desired servo position in degrees \cell }
{\row }
}
}{
Definition at line 262 of file Arm.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 262                                 \{\par
263         setServoPosition(WRIST_TWIST, a);\par
264         servoPos[WRIST_TWIST] = a;\par
265     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a35ec7756840d9d32dcfbb88d831f087f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Arm_a35ec7756840d9d32dcfbb88d831f087f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v servoPos\:ChipChipArray::Arm}
{\xe \v ChipChipArray::Arm\:servoPos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8} ChipChipArray::Arm::servoPos[7] = \{ 0, 0, 0, 0, 0, 0, 0 \}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The instantaneous position of each arm servo. \par
}{
Definition at line 34 of file Arm.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b Arm.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChipChipArray::Block Class Reference\par \pard\plain 
{\tc\tcl2 \v ChipChipArray::Block}
{\xe \v ChipChipArray::Block}
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
\par
{
{\f2 #include <Block.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Block} (cv::Rect rect, {\b Color} {\b color})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32} {\b area}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cv::Point {\b bottomLeft}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cv::Point {\b bottomRight}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b sint16} {\b dBottom}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b sint16} {\b dLeft}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b sint16} {\b dRight}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b sint16} {\b dTop}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b sint16} {\b dTopBottom}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b sint16} {\b dRightLeft}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b sint16} {\b offset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16} {\b height}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cv::Point {\b topLeft}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cv::Point {\b topRight}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint16} {\b width}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Color} {\b color}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Size} {\b size}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class represents a block. It only works for blocks found with the "boundingRect" algorithm (i.e., it doesn't work for blocks that are skewed on the image). \par
}{
Definition at line 20 of file Block.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Block\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:Block}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ChipChipArray::Block::Block (cv::Rect {\i rect}, {\b Color} {\i color})}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new {\b Block} using the Points in the cv::Rect and the color. Also determines the size based on the area of the {\b Block}. \par
}{
Definition at line 139 of file Block.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 139                                          \{\par
140         // basic geometric properties\par
141         area = rect.area();\par
142         height = rect.height;\par
143         width = rect.width;\par
144 \par
145         // assigning corners\par
146         topLeft = rect.tl();\par
147         bottomRight = rect.br();\par
148         topRight = cv::Point(topLeft.x + width, topLeft.y);\par
149         bottomLeft = cv::Point(topLeft.x, topLeft.y + height);\par
150         offset = (sint16)(topLeft.x + width / 2) - IMG_WIDTH / 2;\par
151 \par
152         // calculating offsets (opencv low coordinates start top left)\par
153         dLeft = topLeft.x;\par
154         dRight = IMG_WIDTH - topRight.x;\par
155         dTop = topLeft.y;\par
156         dBottom = IMG_HEIGHT - bottomRight.y;\par
157         dTopBottom = dTop - dBottom;\par
158         dRightLeft = dRight - dLeft;\par
159 \par
160         // set color and size\par
161         this->color = color;\par
162         size = area > MIN_WHOLE_BLOCK_SIZE ? Size::Long : Size::Short;\par
163     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v area\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:area}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32} ChipChipArray::Block::area}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The area of the block in pixels \par
}{
Definition at line 25 of file Block.hpp.}\par
}
{\xe \v bottomLeft\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:bottomLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
cv::Point ChipChipArray::Block::bottomLeft}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Point of the block's bottom-left corner \par
}{
Definition at line 30 of file Block.hpp.}\par
}
{\xe \v bottomRight\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:bottomRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
cv::Point ChipChipArray::Block::bottomRight}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Point of the block's bottom-right corner \par
}{
Definition at line 35 of file Block.hpp.}\par
}
{\xe \v color\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:color}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Color} ChipChipArray::Block::color}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The detected color of the block \par
}{
Definition at line 107 of file Block.hpp.}\par
}
{\xe \v dBottom\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:dBottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sint16} ChipChipArray::Block::dBottom}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of pixels from the block's bottom edge to the bottom edge of the image frame. \par
}{
Definition at line 41 of file Block.hpp.}\par
}
{\xe \v dLeft\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:dLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sint16} ChipChipArray::Block::dLeft}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of pixels from the block's left edge to the left edge of the image frame. \par
}{
Definition at line 47 of file Block.hpp.}\par
}
{\xe \v dRight\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:dRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sint16} ChipChipArray::Block::dRight}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of pixels from the block's right edge to the right edge of the image frame. \par
}{
Definition at line 53 of file Block.hpp.}\par
}
{\xe \v dRightLeft\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:dRightLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sint16} ChipChipArray::Block::dRightLeft}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The difference between dRight and dLeft. It indicates the relative vertical positioning of the block regardless of the block's area. A positive value indicates the block is off-center towards the left. \par
}{
Definition at line 75 of file Block.hpp.}\par
}
{\xe \v dTop\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:dTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sint16} ChipChipArray::Block::dTop}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of pixels from the block's top edge to the top edge of the image frame. \par
}{
Definition at line 59 of file Block.hpp.}\par
}
{\xe \v dTopBottom\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:dTopBottom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sint16} ChipChipArray::Block::dTopBottom}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The difference between dTop and dBottom. It indicates the relative vertical positioning of the block regardless of the block's area. A positive value indicates the block is off-center towards the bottom. \par
}{
Definition at line 67 of file Block.hpp.}\par
}
{\xe \v height\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:height}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16} ChipChipArray::Block::height}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The height of the block in pixels \par
}{
Definition at line 87 of file Block.hpp.}\par
}
{\xe \v offset\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sint16} ChipChipArray::Block::offset}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The difference in pixels between the vertical center of the image and the vertical center of the block. Assumes image is 1280 pixels wide (like the Raspicam images). \par
}{
Definition at line 82 of file Block.hpp.}\par
}
{\xe \v size\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Size} ChipChipArray::Block::size}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The size of the block (half or whole) \par
}{
Definition at line 112 of file Block.hpp.}\par
}
{\xe \v topLeft\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:topLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
cv::Point ChipChipArray::Block::topLeft}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Point of the block's top-left corner \par
}{
Definition at line 92 of file Block.hpp.}\par
}
{\xe \v topRight\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:topRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
cv::Point ChipChipArray::Block::topRight}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Point of the block's top-right corner \par
}{
Definition at line 97 of file Block.hpp.}\par
}
{\xe \v width\:ChipChipArray::Block}
{\xe \v ChipChipArray::Block\:width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint16} ChipChipArray::Block::width}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The width of the block in pixels \par
}{
Definition at line 102 of file Block.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b Block.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChipChipArray::Grabber Class Reference\par \pard\plain 
{\tc\tcl2 \v ChipChipArray::Grabber}
{\xe \v ChipChipArray::Grabber}
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
\par
{
{\f2 #include <Grabber.hpp>}}\par
Collaboration diagram for ChipChipArray::Grabber:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Grabber} ({\b Zone} {\b zone}, {\b Side} {\b side})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Close} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Result} {\b Load} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Deposit} ({\b Color} color={\b Color::Blue})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Extend} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Block} {\b LocateBlocks} ({\b Color} color={\b Color::Perrywinkle})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Block} {\b LocateBlueBlock} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PiCamera} {\b cam}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Side} {\b side}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Zone} {\b zone}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class finds blocks, identifies them, and sorts them according to color, size, and zone. \par
}{
Definition at line 30 of file Grabber.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Grabber\:ChipChipArray::Grabber}
{\xe \v ChipChipArray::Grabber\:Grabber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ChipChipArray::Grabber::Grabber ({\b Zone} {\i zone}, {\b Side} {\i side})}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the class according to the side and zone and extends the robotic arm into position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i zone} \cell }{the zone (A, B, or C) for which to pick up blocks.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i side} \cell }{the side from which the robot is moving and the position of the blocks (right or left) in the view of the camera to pick up first \cell }
{\row }
}
}{
Definition at line 143 of file Grabber.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 143                                          \{\par
144         log.Status("Opening Grabber");\par
145         log.Verbose("Zone: " + std::to_string(zone));\par
146         log.Verbose("Side: " + std::to_string(side));\par
147 \par
148         this->zone = zone;\par
149         this->side = side;\par
150 \par
151         log.Verbose("Setting HSV threshold values");\par
152 \par
153         rangeVals[Color::Red] = \{ cv::Scalar(0, 20, 60),\par
154             cv::Scalar(12, 255, 255) \};\par
155         rangeVals[Color::Green] = \{ cv::Scalar(49, 41, 17),\par
156             cv::Scalar(63, 255, 255) \};\par
157         rangeVals[Color::Blue] = \{ cv::Scalar(70, 0, 0),\par
158             cv::Scalar(100, 255, 255) \};\par
159 \par
160         /* Remember, we're only pretending this color's image is in HSV space.\par
161          * It's really in YUV, as required by Jacob yellow-detection algorithm. */\par
162         rangeVals[Color::Yellow] = \{ cv::Scalar(0, 0, 0),\par
163             cv::Scalar(255, 255, 20)\};\par
164     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_a7333f40c135fbe92d59651f75032b4e7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Close\:ChipChipArray::Grabber}
{\xe \v ChipChipArray::Grabber\:Close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Grabber::Close ()}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Closes the {\b Grabber}. Retracts the arm and closes the camera. \par
}{
Definition at line 166 of file Grabber.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 166                         \{\par
167         log.Status("Closing Grabber");\par
168         cam.Close();\par
169     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_aacf089ceb4aa5b263c2cc702fb3daf74_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_aacf089ceb4aa5b263c2cc702fb3daf74_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Deposit\:ChipChipArray::Grabber}
{\xe \v ChipChipArray::Grabber\:Deposit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Grabber::Deposit ({\b Color} {\i color} = {\f2 {\b Color::Blue}}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deposits blocks in the storage/unloading unit. \par
}{
Definition at line 171 of file Grabber.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 171                                      \{\par
172         if(color == Color::Blue) \{\par
173             arm.ClawClose();\par
174             sleep(1);\par
175             arm.BaseTilt(160);\par
176             sleep(1);\par
177             arm.Elbow(130);\par
178             sleep(1);\par
179             arm.BaseTurn(47);\par
180             sleep(1);\par
181             arm.ClawOpen();\par
182             sleep(1);\par
183         \} else \{\par
184             throw std::runtime_error("Du Idiot! Die Armbewegungen f\'FCr diese "\par
185                     "Farbe sind noch nicht implementiert. Vielleicht sollst "\par
186                     "du die englische Phrase lernen 'Would you like fries "\par
187                     "with that?");\par
188         \}\par
189     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_a44e5aeb908634f68de356ad8df3c4bf1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_a44e5aeb908634f68de356ad8df3c4bf1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Extend\:ChipChipArray::Grabber}
{\xe \v ChipChipArray::Grabber\:Extend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Grabber::Extend (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets arm to generic position roughly right above a stack of blocks. \par
}{
Definition at line 191 of file Grabber.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 191                          \{\par
192         arm.Elbow(180);\par
193         usleep(500000);\par
194         arm.BaseTurn(132);\par
195         arm.BaseTilt(125);\par
196         arm.Elbow(150);\par
197         arm.WristTwist(90);\par
198         arm.ClawOpen();\par
199         sleep(2);\par
200     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_abecb4047b4f7d5a7e691b7fb581b5a39_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_abecb4047b4f7d5a7e691b7fb581b5a39_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Load\:ChipChipArray::Grabber}
{\xe \v ChipChipArray::Grabber\:Load}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Result} ChipChipArray::Grabber::Load ()}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads a block(s) (if possible) at the robot's current position.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the number of half and whole blocks loaded \par
}}{
Definition at line 202 of file Grabber.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 202                          \{\par
203         for(uint8 i = 0; i < 2; i++) \{\par
204             Extend();\par
205 \par
206             try \{\par
207                 Block block = (zone == Zone::A)\par
208                     ? LocateBlocks(Color::Blue) : LocateBlueBlock();\par
209 \par
210                 float32 baseKonstant = 0.5;\par
211                 if(block.dRightLeft > 0) baseKonstant *= -1;\par
212                 float32 degree = baseKonstant * std::sqrt(block.dRightLeft);\par
213                 arm.dBaseTurn(degree);\par
214                 arm.dWristTwist(-degree);\par
215                 sleep(1);\par
216                 arm.BaseTilt(140);\par
217                 sleep(1);\par
218 \par
219                 uint8 bend = (i == 0 ? 100 : 90);\par
220 \par
221                 // lower claw over block\par
222                 for(uint8 j = 140; j >= bend; j -= 10) \{\par
223                     arm.Elbow(j);\par
224                     sleep(1);\par
225                 \}\par
226 \par
227                 // deposit in bin\par
228                 sleep(1);\par
229                 Deposit();\par
230             \} catch(std::exception ex) \{\par
231                 log.Error(std::string("An exception occured attempting "\par
232                             "to load the blocks in function Grabber::Load(): ") \par
233                         + ex.what());\par
234             \}\par
235 \par
236 \par
237             if(i == 0) \{\par
238                 arm.BaseTurn(132);\par
239             \} else \{\par
240                 arm.BaseTurn(135);\par
241                 sleep(1);\par
242                 arm.BaseTilt(180);\par
243                 sleep(1);\par
244                 arm.Elbow(90);\par
245                 sleep(1);\par
246                 arm.Elbow(45);\par
247                 sleep(1);\par
248                 arm.Elbow(0);\par
249             \}\par
250         \}\par
251     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_a56639f8f9ba9468bce4b6d69ceb2eb54_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_a56639f8f9ba9468bce4b6d69ceb2eb54_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v LocateBlocks\:ChipChipArray::Grabber}
{\xe \v ChipChipArray::Grabber\:LocateBlocks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Block} ChipChipArray::Grabber::LocateBlocks ({\b Color} {\i color} = {\f2 {\b Color::Perrywinkle}}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loads a stack of blocks for all zones. Does multiple colors and both sizes.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i color} \cell }{the color block for which to search. Perrywinkle denotes searching for all colors (because who actually knows what color perrywinkle is?).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Block} instance representing the block found \par
}}{
Definition at line 254 of file Grabber.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 254                                            \{\par
255         invokeCount++;\par
256         std::string logstr = "Locating blocks";\par
257 \par
258         if(color == Color::Perrywinkle) \{\par
259             logstr += " (" + std::to_string(color) + ")";\par
260         \}\par
261 \par
262         log.Verbose(logstr);\par
263 \par
264         cv::Mat imgOrig;\par
265         cv::transpose(cam.Snap(), imgOrig);\par
266 \par
267         cv::Mat imgHSV;\par
268         cv::Mat imgThresh;\par
269         std::vector<cv::Rect> blocks;\par
270         std::vector<Color> colors;\par
271 \par
272         uint8 loopNum = (color == Color::Perrywinkle ? rangeVals.size() : 1);\par
273 \par
274         for(int i = 0; i < loopNum; i++) \{\par
275             if(loopNum > 1) \{\par
276                 switch(i) \{\par
277                     case 0:\par
278                         color = Color::Red;\par
279                         break;\par
280 \par
281                     case 1:\par
282                         color = Color::Green;\par
283                         break;\par
284 \par
285                     case 2:\par
286                         color = Color::Blue;\par
287                         break;\par
288 \par
289                         /* Must be last, because it changes imgHSV from HSV space\par
290                          * to YUV space. */\par
291                     case 3: \par
292                         color = Color::Yellow;\par
293                         break;\par
294                 \}\par
295             \}\par
296 \par
297             log.Verbose("Searching: " + std::to_string(color));\par
298 \par
299             if(color == Color::Yellow) \{\par
300                 cv::Mat temp;\par
301                 imgOrig.copyTo(temp);\par
302                 cv::cvtColor(imgOrig, imgHSV, CV_BGR2YUV);\par
303                 cv::cvtColor(imgHSV, temp, CV_HSV2BGR);\par
304                 cv::cvtColor(temp, imgHSV, cv::COLOR_BGR2HSV);\par
305                 log.Image(temp, "yuv_yellow_" + std::to_string(color)\par
306                         + "_" + std::to_string(zone)\par
307                         + std::to_string(invokeCount)\par
308                         + ".bmp");\par
309             \} else \{\par
310                 cv::cvtColor(imgOrig, imgHSV, cv::COLOR_BGR2HSV);\par
311             \}\par
312 \par
313             cv::inRange(imgHSV, rangeVals[color][0],\par
314                     rangeVals[color][1], imgThresh);\par
315 \par
316             /* \par
317              * Not quite sure what all this does, but it seems to\par
318              * relate to smoothing the image\par
319              */\par
320             cv::erode(imgThresh, imgThresh,\par
321                     cv::getStructuringElement(\par
322                         cv::MORPH_ELLIPSE,\par
323                         cv::Size(5, 5)));\par
324             cv::dilate(imgThresh, imgThresh,\par
325                     cv::getStructuringElement(\par
326                         cv::MORPH_ELLIPSE,\par
327                         cv::Size(5, 5)));\par
328             cv::dilate(imgThresh, imgThresh,\par
329                     cv::getStructuringElement(\par
330                         cv::MORPH_ELLIPSE,\par
331                         cv::Size(5, 5)));\par
332             cv::erode(imgThresh, imgThresh,\par
333                     cv::getStructuringElement(\par
334                         cv::MORPH_ELLIPSE,\par
335                         cv::Size(5, 5)));\par
336 \par
337             log.Image(imgThresh, "thresh_" + std::to_string(color)\par
338                     + "_" + std::to_string(zone)\par
339                     + std::to_string(invokeCount)\par
340                     + ".bmp");\par
341 \par
342             // calculate contours\par
343             std::vector<std::vector<cv::Point>> contours;\par
344             cv::findContours(imgThresh, contours, CV_RETR_TREE,\par
345                     CV_CHAIN_APPROX_SIMPLE,\par
346                     cv::Point(0, 0));\par
347             std::vector<std::vector<cv::Point>>\par
348                 contours_poly(contours.size());\par
349             std::vector<cv::Rect> bounds(contours.size());\par
350 \par
351             // find rectangle around polygon-ish shapes\par
352             for(int i = 0; i < contours.size(); i++) \{\par
353                 uint32 area = cv::contourArea(contours[i]);\par
354 \par
355                 // determine if block and add to blocks vector\par
356                 if(area > MIN_HALF_BLOCK_SIZE) \{\par
357                     cv::approxPolyDP(cv::Mat(contours[i]),\par
358                             contours_poly[i], 20,\par
359                             false);\par
360                     cv::Rect rect = cv::boundingRect(\par
361                             cv::Mat(contours_poly[i]));\par
362                     log.Debug(std::to_string(color)\par
363                             + " block detected "\par
364                             "with area "\par
365                             + std::to_string(\par
366                                 area));\par
367                     blocks.push_back(rect);\par
368                     colors.push_back(color);\par
369                 \}\par
370             \}\par
371         \}\par
372 \par
373         if(blocks.size() == 0) \{\par
374             log.Image(imgOrig, "original_" + std::to_string(zone)\par
375                     + std::to_string(invokeCount)\par
376                     + "_no_blocks.bmp");\par
377             throw std::runtime_error("No blocks found!");\par
378         \} else \{\par
379             log.Status(std::to_string(blocks.size())\par
380                     + " blocks found");\par
381         \}\par
382 \par
383         // coordinates start in top right\par
384         Block block = Block(blocks[0], colors[0]);\par
385 \par
386         if(blocks.size() > 1) \{\par
387             for(int i = 1; i < blocks.size(); i++) \{ \par
388                 if((side == Side::Right && blocks[i].x \par
389                             > block.topLeft.x)\par
390                         || (side == Side::Left\par
391                             && blocks[i].x\par
392                             < block.topLeft.x)) \{\par
393                     block = Block(blocks[i], colors[i]);\par
394                 \}\par
395             \}\par
396         \}\par
397 \par
398         log.Status(std::to_string(block.color) + " block is located");\par
399 \par
400         log.Debug("Block properties => area: " + std::to_string(block.area)\par
401                 + ", height: " + std::to_string(block.height) + ", width: "\par
402                 + std::to_string(block.width) + ", offset: "\par
403                 + std::to_string(block.offset) + ", color: "\par
404                 + std::to_string(block.color) + ", size: "\par
405                 + std::to_string(block.size));\par
406 \par
407         /* \par
408          * Draw surrounding rectangles from above on original\par
409          * image.\par
410          */\par
411         cv::rectangle(imgOrig, block.topLeft , block.bottomRight,\par
412                 cv::Scalar(255, 0, 0), 4, 8);\par
413         log.Image(imgOrig, "original_" + std::to_string(zone)\par
414                 + std::to_string(invokeCount)\par
415                 + ".bmp");\par
416 \par
417         return block;\par
418     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_af49248c957a1695dcde79c0f5f8df99b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_af49248c957a1695dcde79c0f5f8df99b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v LocateBlueBlock\:ChipChipArray::Grabber}
{\xe \v ChipChipArray::Grabber\:LocateBlueBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Block} ChipChipArray::Grabber::LocateBlueBlock (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finds whole, blue blocks.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b Block} instance representing the block found \par
}}{
Definition at line 420 of file Grabber.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 420                                    \{\par
421         std::vector<cv::Mat> channels;\par
422         std::vector<cv::Rect> blocks;   \par
423 \par
424         invokeCount++;\par
425         log.Status("Locating blue blocks");\par
426 \par
427         cv::Mat img;\par
428         cv::Mat imgThresh;\par
429         cv::split(cam.Snap(), channels);\par
430         cv::transpose(channels[0], img);\par
431 \par
432         log.Verbose("Searching: Blue block");\par
433         cv::inRange(img, 30, 255, imgThresh);\par
434         log.Image(imgThresh, "thresh_blue" + std::to_string(zone)\par
435                 + std::to_string(invokeCount) + ".bmp");\par
436 \par
437         // calculate contours\par
438         std::vector<std::vector<cv::Point>> contours;\par
439         cv::findContours(imgThresh, contours, CV_RETR_TREE,\par
440                 CV_CHAIN_APPROX_SIMPLE,\par
441                 cv::Point(0, 0));\par
442         std::vector<std::vector<cv::Point>>\par
443             contours_poly(contours.size());\par
444         std::vector<cv::Rect> bounds(contours.size());\par
445 \par
446         // find rectangle around polygon-ish shapes\par
447         for(int i = 0; i < contours.size(); i++) \{\par
448             uint32 area = cv::contourArea(contours[i]);\par
449 \par
450             // determine if block and add to blocks vector\par
451             if(area > MIN_HALF_BLOCK_SIZE) \{\par
452                 cv::approxPolyDP(cv::Mat(contours[i]),\par
453                         contours_poly[i], 20,\par
454                         false);\par
455                 cv::Rect rect = cv::boundingRect(\par
456                         cv::Mat(contours_poly[i]));\par
457                 log.Debug("Blue block detected with area "\par
458                         + std::to_string(area));\par
459                 blocks.push_back(rect);\par
460             \}\par
461         \}\par
462 \par
463 \par
464         if(blocks.size() == 0) \{\par
465             log.Image(img, "original_" + std::to_string(zone)\par
466                     + std::to_string(invokeCount)\par
467                     + "_no_blocks.bmp");\par
468             throw std::runtime_error("No blocks found!");\par
469         \} else \{\par
470             log.Status(std::to_string(blocks.size())\par
471                     + " blocks found");\par
472         \}\par
473 \par
474         // coordinates start in top right\par
475         Block block = Block(blocks[0], Color::Blue);\par
476 \par
477         if(blocks.size() > 1) \{\par
478             for(int i = 1; i < blocks.size(); i++) \{ \par
479                 if((side == Side::Right && blocks[i].x \par
480                             > block.topLeft.x)\par
481                         || (side == Side::Left\par
482                             && blocks[i].x\par
483                             < block.topLeft.x)) \{\par
484                     block = Block(blocks[i], Color::Blue);\par
485                 \}\par
486             \}\par
487         \}\par
488 \par
489         log.Status(std::to_string(block.color) + " block is located");\par
490 \par
491         log.Debug("Block properties => area: " + std::to_string(block.area)\par
492                 + ", height: " + std::to_string(block.height) + ", width: "\par
493                 + std::to_string(block.width) + ", offset: "\par
494                 + std::to_string(block.offset) + ", color: "\par
495                 + std::to_string(block.color) + ", size: "\par
496                 + std::to_string(block.size));\par
497 \par
498         /* \par
499          * Draw surrounding rectangles from above on original\par
500          * image.\par
501          */\par
502         cv::rectangle(img, block.topLeft , block.bottomRight,\par
503                 cv::Scalar(255, 0, 0), 4, 8);\par
504         log.Image(img, "original_" + std::to_string(zone)\par
505                 + std::to_string(invokeCount)\par
506                 + ".bmp");\par
507 \par
508         return block;\par
509     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_ab9b0d6a64b2c94c0d0f810a5ebeef6ec_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Grabber_ab9b0d6a64b2c94c0d0f810a5ebeef6ec_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v cam\:ChipChipArray::Grabber}
{\xe \v ChipChipArray::Grabber\:cam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PiCamera} ChipChipArray::Grabber::cam{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Raspicam \par
}{
Definition at line 64 of file Grabber.hpp.}\par
}
{\xe \v side\:ChipChipArray::Grabber}
{\xe \v ChipChipArray::Grabber\:side}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Side} ChipChipArray::Grabber::side{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The side from which the robot is coming (i.e., the side where the higher priority blocks are to be picked up. \par
}{
Definition at line 71 of file Grabber.hpp.}\par
}
{\xe \v zone\:ChipChipArray::Grabber}
{\xe \v ChipChipArray::Grabber\:zone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Zone} ChipChipArray::Grabber::zone{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The zone in which blocks are being loaded. \par
}{
Definition at line 76 of file Grabber.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b Grabber.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChipChipArray::Log Class Reference\par \pard\plain 
{\tc\tcl2 \v ChipChipArray::Log}
{\xe \v ChipChipArray::Log}
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
\par
{
{\f2 #include <Log.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Log} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Log} (auto dir, {\b LogMode} mode={\b LogMode::Text})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Log} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Debug} (auto mesg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Error} (auto mesg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Image} (cv::Mat image, auto filename)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Open} (auto dir, {\b LogMode} mode={\b LogMode::Text})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Status} (auto mesg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Variable} (auto name, auto value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Verbose} (auto mesg)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class logs the text and images passed to it to specificed directory.\par
A "container" directory to which the class can write is passed in the constructor. When the {\b Log} is initialized with {\b LogMode::Text}, a new log file is created with a filename based on the time of initialization in the given directory. When initialized in {\b LogMode::Multi}, it will create a subdirectory in the given directory with a name based on time. In this new directory, a log file will be created. Images may later be stored in this directory with names based on the order in which they were saved.\par
This class DOES NOT WORK without compiling without a "LOG" definition (#define LOG or -DLOG). \par
}{
Definition at line 35 of file Log.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Log\:ChipChipArray::Log}
{\xe \v ChipChipArray::Log\:Log}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ChipChipArray::Log::Log (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes {\b Log} object but does not open log. {\b Open()} must be called. \par
}{
Definition at line 41 of file Log.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41 \{\};\par
}
}
{\xe \v Log\:ChipChipArray::Log}
{\xe \v ChipChipArray::Log\:Log}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ChipChipArray::Log::Log (auto {\i dir}, {\b LogMode} {\i mode} = {\f2 {\b LogMode::Text}})}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the {\b Log}.\par
A new log file is created in dir if {\b LogMode::Text} is given. The file will have a name based on the current date and time. If {\b LogMode::Multi} is given, a new directory is created, and a log file with a name based on the current date and time is created inside it.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dir} \cell }{the directory for the newly created logfile/folder\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mode} \cell }{the LogMode \cell }
{\row }
}
}{
Definition at line 187 of file Log.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 187                                    \{\par
188 #ifdef LOG\par
189         Open(dir, mode);\par
190 #endif\par
191     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Log_a4cd28a821789b39e936a6e346329d65b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v ~Log\:ChipChipArray::Log}
{\xe \v ChipChipArray::Log\:~Log}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ChipChipArray::Log::~Log ()}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys the {\b Log} and closes the logfile. \par
}{
Definition at line 193 of file Log.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 193               \{\par
194 #ifdef LOG\par
195         try \{\par
196             file.flush();\par
197             file.close();\par
198         \} catch (std::ofstream::failure f) \{\par
199             LogError("Gosh dang it! A fatal error has occured " \par
200                     "closing the logfile.", f);\par
201         \}\par
202 #endif\par
203     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Debug\:ChipChipArray::Log}
{\xe \v ChipChipArray::Log\:Debug}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Log::Debug (auto {\i mesg})}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes "DEBUG: " to the log file along with the message passed. Should be used for generic debugging information. If recording the value of a variable in the {\b Log} is desired, use the function {\b Variable()} instead.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mesg} \cell }{the message to record in the logfile \cell }
{\row }
}
}{
Definition at line 205 of file Log.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 205                              \{\par
206 #ifdef LOG\par
207         try \{\par
208             file << "DEBUG: " << mesg << std::endl;\par
209             file.flush();\par
210         \} catch(std::ofstream::failure f) \{\par
211             LogError("Debug() write error", f);\par
212         \}\par
213 #endif\par
214     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Log_ac32b435af1577e4ebc67af2bdfea8eff_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Error\:ChipChipArray::Log}
{\xe \v ChipChipArray::Log\:Error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Log::Error (auto {\i mesg})}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes "ERROR: " to the log file. Should only be use when an exception is thrown.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mesg} \cell }{the message to record in the log \cell }
{\row }
}
}{
Definition at line 216 of file Log.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 216                              \{\par
217 #ifdef LOG\par
218         try \{\par
219             file << "ERROR: " << mesg << std::endl;\par
220             file.flush();\par
221         \} catch(std::ofstream::failure f) \{\par
222             LogError("Error() write error", f);\par
223         \}\par
224 #endif\par
225     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Log_aba7b7b0555f49f4dcf15f4b9fd3e6b34_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Image\:ChipChipArray::Log}
{\xe \v ChipChipArray::Log\:Image}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Log::Image (cv::Mat {\i image}, auto {\i filename})}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a bitmap image in the subdirectory created by the {\b Log} during initialization. Does nothing if {\b LogMode::Text} was passed in the constructor.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i image} \cell }{the image to save \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{the filename for the saved image \cell }
{\row }
}
}{
Definition at line 227 of file Log.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 227                                               \{\par
228 #ifdef LOG\par
229         try \{\par
230             cv::imwrite(dir + std::string(filename), image);\par
231         \} catch(std::ofstream::failure f) \{\par
232             LogError("Image() write error", f);\par
233         \} catch(std::exception ex) \{\par
234             Error("Error writing image " + std::string(filename));\par
235         \}\par
236 #endif\par
237     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Log_a65bbab057c8b1453f9e4efcfee7522c4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Log_a65bbab057c8b1453f9e4efcfee7522c4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Open\:ChipChipArray::Log}
{\xe \v ChipChipArray::Log\:Open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Log::Open (auto {\i dir}, {\b LogMode} {\i mode} = {\f2 {\b LogMode::Text}})}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 247 of file Log.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 247                                          \{\par
248 #ifdef LOG\par
249         // format date and time\par
250         char date[32];\par
251         time_t sec = time(nullptr);\par
252         struct tm * loctime = localtime(&sec);\par
253         strftime(date, 32, "%m-%d_%H-%M-%S", loctime);\par
254 \par
255         // create temperary strings\par
256         this->dir = std::string(dir);\par
257         std::string datestr = std::string(date);\par
258 \par
259         // add path separator if necessary\par
260         if(this->dir[this->dir.length() - 1] != PATH_SEP) \{\par
261             this->dir += PATH_SEP;\par
262         \}\par
263 \par
264         // add directory for log and images if necessary\par
265         if(mode == LogMode::Multi) this->dir += datestr + PATH_SEP;\par
266 \par
267         int ret = mkdir(this->dir.c_str(), S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP\par
268                 | S_IROTH | S_IWOTH | S_IXUSR | S_IXGRP\par
269                 | S_IXOTH);\par
270 \par
271         filename = this->dir + datestr + ".log";\par
272 \par
273         // set class mode\par
274         this->mode = mode;\par
275 \par
276         // Initializing file\par
277         file.exceptions(std::ofstream::failbit\par
278                 | std::ofstream::badbit);\par
279 \par
280         try \{\par
281             file.open(filename, std::ofstream::out\par
282                     | std::ofstream::app);\par
283         \} catch(std::ofstream::failure ex) \{\par
284             LogError("Oh, no! An error has occurred opening the "\par
285                     "log file.", ex);\par
286         \}\par
287 #endif\par
288     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Log_ad27a06a4561f2f59159bd8a7fc2fed3b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Status\:ChipChipArray::Log}
{\xe \v ChipChipArray::Log\:Status}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Log::Status (auto {\i mesg})}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes "STATUS: " to the log file. Should be used when recording the status or state of the program. It should not be used to record microalgorithmic changes. Use {\b Verbose()} for these instead.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mesg} \cell }{the message to record in the logfile \cell }
{\row }
}
}{
Definition at line 290 of file Log.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 290                               \{\par
291 #ifdef LOG\par
292         try \{\par
293             file << "STATUS: " << mesg << std::endl;\par
294             file.flush();\par
295         \} catch (std::ofstream::failure f) \{\par
296             LogError("Status() write error", f);\par
297         \}\par
298 #endif\par
299     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Log_a66575b6e94c6112e4cefa5736cb996e0_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Variable\:ChipChipArray::Log}
{\xe \v ChipChipArray::Log\:Variable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Log::Variable (auto {\i name}, auto {\i value})}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes "VARIABLE: " to the log file. Should be used whenever recording the value of a variable is desired.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i name} \cell }{the variable name to record \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{the variable value to record \cell }
{\row }
}
}{
Definition at line 301 of file Log.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 301                                             \{\par
302 #ifdef LOG\par
303         try \{\par
304             file << "VARIABLE: " << name << " = " << value\par
305                 << std::endl;\par
306             file.flush();\par
307         \} catch(std::ofstream::failure f) \{\par
308             LogError("Variable() write error", f);\par
309         \}\par
310 #endif\par
311     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Log_a8849569720c26e335e7ef4dcb912170b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Verbose\:ChipChipArray::Log}
{\xe \v ChipChipArray::Log\:Verbose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::Log::Verbose (auto {\i mesg})}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes "VERBOSE: " to the log file. Should only be used for recording small, specific portions of code. To record a change in the more general state of the program, use {\b Status()} instead.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mesg} \cell }{the message to record in the logfile \cell }
{\row }
}
}{
Definition at line 313 of file Log.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 313                                \{\par
314 #ifdef LOG\par
315         try \{\par
316             file << "VERBOSE: " << mesg << std::endl;\par
317             file.flush();\par
318         \} catch(std::ofstream::failure f) \{\par
319             LogError("Verbose() write error", f);\par
320         \}\par
321 #endif\par
322     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1Log_a154a5f38d9c7a767693b242684a3d4d9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b Log.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChipChipArray::PiCamera Class Reference\par \pard\plain 
{\tc\tcl2 \v ChipChipArray::PiCamera}
{\xe \v ChipChipArray::PiCamera}
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
\par
{
{\f2 #include <PiCamera.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PiCamera} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PiCamera} (bool useColor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Close} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cv::Mat {\b Snap} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a basic wrapper to allow the Raspicam to interface with OpenCV. It uses another wrapper class, Raspicam, provided by C\'E9dric Verstraeten ({\f2 https://github.com/cedricve/raspicam}). \par
}{
Definition at line 24 of file PiCamera.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PiCamera\:ChipChipArray::PiCamera}
{\xe \v ChipChipArray::PiCamera\:PiCamera}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ChipChipArray::PiCamera::PiCamera (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Opens the camera and configures it for color images. \par
}{
Definition at line 29 of file PiCamera.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29 : PiCamera(true) \{\};\par
}
}
{\xe \v PiCamera\:ChipChipArray::PiCamera}
{\xe \v ChipChipArray::PiCamera\:PiCamera}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ChipChipArray::PiCamera::PiCamera (bool {\i useColor})}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Opens the camera.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i useColor} \cell }{Specifices whether camera should make color images. TRUE = color, FALSE = grayscale. \cell }
{\row }
}
}{
Definition at line 59 of file PiCamera.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 59                                     \{\par
60         cam.set(CV_CAP_PROP_FORMAT, (useColor ? CV_16UC3 : CV_16UC1));\par
61         cam.open();\par
62         usleep(500000);  // required to allow camera time to adjust!\par
63     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Close\:ChipChipArray::PiCamera}
{\xe \v ChipChipArray::PiCamera\:Close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChipChipArray::PiCamera::Close ()}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Closes connection to camera. \par
}{
Definition at line 65 of file PiCamera.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 65                          \{\par
66         cam.release();\par
67     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1PiCamera_a38f8205921d6deec5a2c360ea7d24cc5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v Snap\:ChipChipArray::PiCamera}
{\xe \v ChipChipArray::PiCamera\:Snap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
cv::Mat ChipChipArray::PiCamera::Snap ()}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Makes picture.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid OpenCV Mat object (i.e., an image) from the camera \par
}}{
Definition at line 69 of file PiCamera.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 69                          \{\par
70         if(!cam.isOpened()) throw std::runtime_error("Camera "\par
71                 "is not open!");\par
72 \par
73         cv::Mat image;\par
74         cam.grab();\par
75         cam.retrieve(image);\par
76         return image;\par
77     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classChipChipArray_1_1PiCamera_a58fb0de02570dce9a9cb60a1a04fb84f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b PiCamera.hpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
etc/doxygen.config File Reference\par \pard\plain 
{\tc\tcl2 \v etc/doxygen.config}
{\xe \v etc/doxygen.config}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Doxygen configuration file. }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Doxygen configuration file. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b doxygen.config}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
makefile File Reference\par \pard\plain 
{\tc\tcl2 \v makefile}
{\xe \v makefile}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Project makefile containing recipes for compiling the actual application, test applications, and generating documentation. }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Project makefile containing recipes for compiling the actual application, test applications, and generating documentation. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b makefile}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Adafruit_PWMServoDriver.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/Adafruit_PWMServoDriver.cpp}
{\xe \v src/Adafruit_PWMServoDriver.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the function and class definitions necessary for the PWM servo driver. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Adafruit_PWMServoDriver.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Adafruit_PWMServoDriver.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Adafruit__PWMServoDriver_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Adafruit__PWMServoDriver_8cpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ENABLE_DEBUG_OUTPUT}\~ false\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the function and class definitions necessary for the PWM servo driver. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Limor Frief/Ladyadda \par
Nickolas Neely \par
}}{
Definition in file {\b Adafruit_PWMServoDriver.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ENABLE_DEBUG_OUTPUT\:Adafruit_PWMServoDriver.cpp}
{\xe \v Adafruit_PWMServoDriver.cpp\:ENABLE_DEBUG_OUTPUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ENABLE_DEBUG_OUTPUT\~ false}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file Adafruit_PWMServoDriver.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Adafruit_PWMServoDriver.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/Adafruit_PWMServoDriver.h}
{\xe \v src/Adafruit_PWMServoDriver.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <wiringPi.h>}\par
{\f2 #include <ctype.h>}\par
{\f2 #include <iostream>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <wiringPiI2C.h>}\par
{\f2 #include <cmath>}\par
{\f2 #include <errno.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <string>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Adafruit_PWMServoDriver.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Adafruit__PWMServoDriver_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Adafruit__PWMServoDriver_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Adafruit_PWMServoDriver}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCA9685_SUBADR1}\~ 0x2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCA9685_SUBADR2}\~ 0x3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCA9685_SUBADR3}\~ 0x4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCA9685_MODE1}\~ 0x0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PCA9685_PRESCALE}\~ 0xFE\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LED0_ON_L}\~ 0x6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LED0_ON_H}\~ 0x7\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LED0_OFF_L}\~ 0x8\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LED0_OFF_H}\~ 0x9\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ALLLED_ON_L}\~ 0xFA\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ALLLED_ON_H}\~ 0xFB\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ALLLED_OFF_L}\~ 0xFC\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ALLLED_OFF_H}\~ 0xFD\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b uint8_t}\~ unsigned char\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b uint16_t}\~ unsigned short int\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Limor Fried/Ladyada \par
Nickolas Neely  Contains the function and class headers necessary for the PWM servo driver. \par
}}{
Definition in file {\b Adafruit_PWMServoDriver.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ALLLED_OFF_H\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:ALLLED_OFF_H}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ALLLED_OFF_H\~ 0xFD}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v ALLLED_OFF_L\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:ALLLED_OFF_L}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ALLLED_OFF_L\~ 0xFC}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v ALLLED_ON_H\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:ALLLED_ON_H}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ALLLED_ON_H\~ 0xFB}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v ALLLED_ON_L\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:ALLLED_ON_L}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ALLLED_ON_L\~ 0xFA}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v LED0_OFF_H\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:LED0_OFF_H}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LED0_OFF_H\~ 0x9}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 57 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v LED0_OFF_L\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:LED0_OFF_L}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LED0_OFF_L\~ 0x8}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v LED0_ON_H\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:LED0_ON_H}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LED0_ON_H\~ 0x7}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v LED0_ON_L\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:LED0_ON_L}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LED0_ON_L\~ 0x6}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 54 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v PCA9685_MODE1\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:PCA9685_MODE1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCA9685_MODE1\~ 0x0}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v PCA9685_PRESCALE\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:PCA9685_PRESCALE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCA9685_PRESCALE\~ 0xFE}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 52 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v PCA9685_SUBADR1\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:PCA9685_SUBADR1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCA9685_SUBADR1\~ 0x2}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v PCA9685_SUBADR2\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:PCA9685_SUBADR2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCA9685_SUBADR2\~ 0x3}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v PCA9685_SUBADR3\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:PCA9685_SUBADR3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PCA9685_SUBADR3\~ 0x4}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 49 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v uint16_t\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:uint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define uint16_t\~ unsigned short int}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file Adafruit_PWMServoDriver.h.}\par
}
{\xe \v uint8_t\:Adafruit_PWMServoDriver.h}
{\xe \v Adafruit_PWMServoDriver.h\:uint8_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define uint8_t\~ unsigned char}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file Adafruit_PWMServoDriver.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Arm.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/Arm.hpp}
{\xe \v src/Arm.hpp}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the Arm class used to control the robotic arm. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <unistd.h>}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "Servo_Position_Shell.cpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Arm.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Arm_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Arm_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChipChipArray::Arm}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b ChipChipArray}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WRIST_TWIST}\~ {\b WRIST_PAN}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the Arm class used to control the robotic arm. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b Arm.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v WRIST_TWIST\:Arm.hpp}
{\xe \v Arm.hpp\:WRIST_TWIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WRIST_TWIST\~ {\b WRIST_PAN}}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file Arm.hpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Block.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/Block.hpp}
{\xe \v src/Block.hpp}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains Block class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <opencv2/core/core.hpp>}\par
{\f2 #include "definitions.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Block.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Block_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Block_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChipChipArray::Block}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b ChipChipArray}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains Block class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b Block.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/cv_hue.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/cv_hue.cpp}
{\xe \v src/cv_hue.cpp}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains program formally used to find HSV values for blocks. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include "opencv2/highgui/highgui.hpp"}\par
{\f2 #include "opencv2/imgproc/imgproc.hpp"}\par
{\f2 #include "PiCamera.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for cv_hue.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "cv__hue_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b ChipChipArray}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ChipChipArray::main} (int argc, char **argv)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains program formally used to find HSV values for blocks. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Shermal Fernando \par
Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b cv_hue.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/cv_shape.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/cv_shape.cpp}
{\xe \v src/cv_shape.cpp}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to aid in determining HSV ranges. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <opencv2/highgui/highgui.hpp>}\par
{\f2 #include <opencv2/imgproc/imgproc.hpp>}\par
{\f2 #include <string>}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "PiCamera.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for cv_shape.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "cv__shape_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to aid in determining HSV ranges. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Shermal Fernando \par
Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b cv_shape.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:cv_shape.cpp}
{\xe \v cv_shape.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program (a single function) is a test of the computer vision algorithms for loading the blocks. It will likely be in development for some time to come. The plan currently is to develop and test all CV algorithms for block loading here before moving it all into class functions and testing again.\par
This code is based on several online articles:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
"Color Detectionn & Object Tracking" by Shermal Fernando ({\f2 http://opencv-srf.blogspot.com/2010/09/object-detection-using-color-seperation.html})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
"Shape Detection & Tracking using Contours" by Shermal Fernando ({\f2 http://opencv-srf.blogspot.com/2011/09/object-detection-tracking-using-contours.html})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
"Creating Bounding boxes and circles for contours" in the OpenCV 2.4 Tutorials ({\f2 http://opencv-srf.blogspot.com/2011/09/object-detection-tracking-using-contours.html}) \par}
}{
Definition at line 37 of file cv_shape.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 37            \{\par
38     PiCamera cam;\par
39 \par
40     // window names\par
41     string control = "Settings";\par
42     string winThresh = "Image Threshold";\par
43     string winContours = "Contours Detected";\par
44 \par
45     // control (trackbar) variables\par
46     int lowH = 0;  // hue\par
47     int highH = 255;\par
48     int lowS = 0;  // saturation\par
49     int highS = 255;\par
50     int lowV = 0;  // value\par
51     int highV = 255;\par
52     int polyEps = 3;  // max dif b/t bin shape edge & est poly edge\par
53 \par
54     // opening windows\par
55     namedWindow(control, CV_WINDOW_AUTOSIZE);\par
56     namedWindow(winThresh, CV_WINDOW_AUTOSIZE);\par
57     namedWindow(winContours, CV_WINDOW_AUTOSIZE);\par
58 \par
59     // creating control trackbars\par
60     createTrackbar("Hue Min", control, &lowH, highH);\par
61     createTrackbar("Hue Max", control, &highH, highH);\par
62     createTrackbar("Sat Min", control, &lowS, highS);\par
63     createTrackbar("Sat Max", control, &highS, highS);\par
64     createTrackbar("Val Min", control, &lowV, highV);\par
65     createTrackbar("Val Max", control, &highV, highV);\par
66     createTrackbar("Polygon Epsilon", control, &polyEps, 20);\par
67 \par
68     while(true) \{\par
69         Mat imgOrig = cam.Snap();  // real iage\par
70         Mat imgHSV;  // RGB image converted to HSV space\par
71         Mat imgThresh;  // binary threshold image\par
72         //cvtColor(imgOrig, imgHSV, CV_BGR2YUV);\par
73         //cvtColor(imgHSV, imgOrig, CV_HSV2BGR);\par
74         cvtColor(imgOrig, imgHSV, COLOR_BGR2HSV);\par
75 \par
76         // create binary image\par
77         inRange(imgHSV, Scalar(lowH, lowS, lowV), Scalar(highH, highS,\par
78                     highV), imgThresh);\par
79 \par
80         /* \par
81          * Not quite sure what all this does, but it seems to\par
82          * relate to smoothing the image\par
83          */\par
84         erode(imgThresh, imgThresh, getStructuringElement(\par
85                     MORPH_ELLIPSE, cv::Size(5, 5)));\par
86         dilate(imgThresh, imgThresh, getStructuringElement(\par
87                     MORPH_ELLIPSE, cv::Size(5, 5)));\par
88         dilate(imgThresh, imgThresh, getStructuringElement(\par
89                     MORPH_ELLIPSE, cv::Size(5, 5)));\par
90         erode(imgThresh, imgThresh, getStructuringElement(\par
91                     MORPH_ELLIPSE, cv::Size(5, 5)));\par
92 \par
93         // show binary image in threshold window\par
94         imshow(winThresh, imgThresh);\par
95 \par
96         // calculate contours\par
97         vector<vector<Point>> contours;\par
98         findContours(imgThresh, contours, CV_RETR_TREE,\par
99                 CV_CHAIN_APPROX_SIMPLE, Point(0, 0));\par
100         vector<vector<Point>> contours_poly(contours.size());\par
101         vector<Rect> bounds(contours.size());\par
102         int maxArea = 0;\par
103         int offset;\par
104 \par
105         // find rectangle around polygon-ish shapes\par
106         for(int i = 0; i < contours.size(); i++) \{\par
107             approxPolyDP(Mat(contours[i]), contours_poly[i],\par
108                     polyEps, false);\par
109             bounds[i] = boundingRect(Mat(contours_poly[i]));\par
110         \}\par
111 \par
112         /* \par
113          * Draw surrounding rectangles from above on original\par
114          * image.\par
115          */\par
116         for(int i = 0; i < contours.size(); i++) \{\par
117             rectangle(imgOrig, bounds[i].tl(), bounds[i].br(),\par
118                     Scalar(255, 0, 0), 2, 8, 0);\par
119             //drawContours(imgOrig, contours_poly, i,\par
120             //      Scalar(255, 0, 0), 4, 8);\par
121             int area = bounds[i].width * bounds[i].height;\par
122 \par
123             if(area > maxArea) \{\par
124                 offset = abs(640 - (bounds[i].tl().x + bounds[i].width / 2));\par
125                 maxArea = area;\par
126             \}\par
127         \}\par
128 \par
129         cout << "Block area: " << maxArea << " pixels\\t\\t" \par
130             << "Center offset: " << offset << endl;\par
131         imshow(winContours, imgOrig);  // show original image with rectangles\par
132         waitKey(50);  // has to be here :(\par
133     \}\par
134 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "cv__shape_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/cv_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/cv_test.cpp}
{\xe \v src/cv_test.cpp}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains program used to test PiCamera class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "Block.hpp"}\par
{\f2 #include "Grabber.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for cv_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "cv__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains program used to test PiCamera class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b cv_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:cv_test.cpp}
{\xe \v cv_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program was used solely to test the PiCamera wrapper class and its compatibility with the raspicam wrapper and ultimately OpenCV. \par
}{
Definition at line 19 of file cv_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19            \{\par
20     Grabber g(Zone::C, Side::Left);\par
21     Block block = g.LocateBlock();\par
22     g.Close();\par
23     std::cout << std::to_string(block.color) << std::endl;\par
24     std::cout << "Offset: " << block.offset << std::endl;\par
25 \par
26     Grabber g2(Zone::B, Side::Right);\par
27     Block block2 = g2.LocateBlock();\par
28     g2.Close();\par
29     std::cout << std::to_string(block2.color) << std::endl;\par
30     std::cout << "Offset: " << block2.offset << std::endl;\par
31 \par
32 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "cv__test_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/dark_magic.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/dark_magic.cpp}
{\xe \v src/dark_magic.cpp}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test code for arm. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdlib>}\par
{\f2 #include <iostream>}\par
{\f2 #include <string>}\par
{\f2 #include "Servo_Position_Shell.cpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for dark_magic.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dark__magic_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test code for arm. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b dark_magic.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:dark_magic.cpp}
{\xe \v dark_magic.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char ** {\i argv})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Controls the positions of the arm servos. Will likely work for other servos on the robot, as well.\par
Usage: arm [SERVO NUMBER] [ANGULAR POSITION DEGREES] \par
}{
Definition at line 21 of file dark_magic.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21                                 \{\par
22     setup();\par
23     \par
24     if(argc != 3) \{\par
25         cout << "Usage: arm [SERVO] [VALUE]" << endl;\par
26     \} else \{\par
27         setServoPosition((Servo)atoi(argv[1]), atoi(argv[2]));\par
28     \}\par
29 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dark__magic_8cpp_a3c04138a5bfe5d72780bb7e82a18e627_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/definitions.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/definitions.hpp}
{\xe \v src/definitions.hpp}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains definitions for architecture-independant numeric variables, enumerations and enumerated classes, and #define'd constants, and to_sting() overloads for the enumerated classes. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <map>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for definitions.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "definitions_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "definitions_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b std}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ENUM}\~ signed char\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ERROR}\~ -1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned char {\b byte}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned char {\b uint8}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef signed char {\b sint8}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned short {\b uint16}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef signed short {\b sint16}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned int {\b uint32}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef signed int {\b sint32}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned long long {\b uint64}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef signed long long {\b sint64}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef float {\b float32}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef double {\b float64}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::map< {\b Zone}, \par
std::map< {\b BlockPosition}, {\b uint8} > > {\b PosMap}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b BlockPosition} : ENUM \{ {\b BlockPosition::Front}, 
{\b BlockPosition::Back}, 
{\b BlockPosition::Middle}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Color} : ENUM \{ {\b Color::Red}, 
{\b Color::Yellow}, 
{\b Color::Green}, 
{\b Color::Blue}, 
{\b Color::Perrywinkle}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Layer} : ENUM \{ {\b Layer::Top}, 
{\b Layer::Bottom}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LogMode} : ENUM \{ {\b LogMode::Text}, 
{\b LogMode::Multi}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Result} : ENUM \{ {\b Result::NoBlocks} = -1, 
{\b Result::NoHalves} = 0, 
{\b Result::TwoHalves} = 2, 
{\b Result::FourHalves} = 4
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Side} : ENUM \{ {\b Side::Left}, 
{\b Side::Right}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Size} : ENUM \{ {\b Size::Short}, 
{\b Size::Long}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Zone} : ENUM \{ {\b Zone::A} = 'A', 
{\b Zone::B} = 'B', 
{\b Zone::C} = 'C'
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b std::to_string} ({\b BlockPosition} pos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b std::to_string} ({\b Color} color)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b std::to_string} ({\b LogMode} mode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b std::to_string} ({\b Result} res)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b std::to_string} ({\b Side} side)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b std::to_string} ({\b Size} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b std::to_string} ({\b Zone} zone)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains definitions for architecture-independant numeric variables, enumerations and enumerated classes, and #define'd constants, and to_sting() overloads for the enumerated classes. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b definitions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ENUM\:definitions.hpp}
{\xe \v definitions.hpp\:ENUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ENUM\~ signed char}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file definitions.hpp.}\par
}
{\xe \v ERROR\:definitions.hpp}
{\xe \v definitions.hpp\:ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ERROR\~ -1}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file definitions.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v byte\:definitions.hpp}
{\xe \v definitions.hpp\:byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned char {\b byte}}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file definitions.hpp.}\par
}
{\xe \v float32\:definitions.hpp}
{\xe \v definitions.hpp\:float32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef float {\b float32}}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file definitions.hpp.}\par
}
{\xe \v float64\:definitions.hpp}
{\xe \v definitions.hpp\:float64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef double {\b float64}}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file definitions.hpp.}\par
}
{\xe \v PosMap\:definitions.hpp}
{\xe \v definitions.hpp\:PosMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::map<{\b Zone}, std::map<{\b BlockPosition}, {\b uint8}> > {\b PosMap}}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file definitions.hpp.}\par
}
{\xe \v sint16\:definitions.hpp}
{\xe \v definitions.hpp\:sint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef signed short {\b sint16}}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file definitions.hpp.}\par
}
{\xe \v sint32\:definitions.hpp}
{\xe \v definitions.hpp\:sint32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef signed int {\b sint32}}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file definitions.hpp.}\par
}
{\xe \v sint64\:definitions.hpp}
{\xe \v definitions.hpp\:sint64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef signed long long {\b sint64}}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file definitions.hpp.}\par
}
{\xe \v sint8\:definitions.hpp}
{\xe \v definitions.hpp\:sint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef signed char {\b sint8}}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file definitions.hpp.}\par
}
{\xe \v uint16\:definitions.hpp}
{\xe \v definitions.hpp\:uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned short {\b uint16}}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file definitions.hpp.}\par
}
{\xe \v uint32\:definitions.hpp}
{\xe \v definitions.hpp\:uint32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned int {\b uint32}}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file definitions.hpp.}\par
}
{\xe \v uint64\:definitions.hpp}
{\xe \v definitions.hpp\:uint64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned long long {\b uint64}}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file definitions.hpp.}\par
}
{\xe \v uint8\:definitions.hpp}
{\xe \v definitions.hpp\:uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned char {\b uint8}}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file definitions.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v BlockPosition\:definitions.hpp}
{\xe \v definitions.hpp\:BlockPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b BlockPosition} : {\b ENUM}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The position of the block relative to the arm. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v Front\:definitions.hpp}
{\xe \v definitions.hpp\:Front}
{\b {\i Front{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
}}  \par
{\xe \v Back\:definitions.hpp}
{\xe \v definitions.hpp\:Back}
{\b {\i Back{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
}}  \par
{\xe \v Middle\:definitions.hpp}
{\xe \v definitions.hpp\:Middle}
{\b {\i Middle{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
}}  \par
}{
Definition at line 37 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 37                          : ENUM \{\par
38     Front,\par
39     Back,\par
40     Middle\par
41 \};\par
}
}
{\xe \v Color\:definitions.hpp}
{\xe \v definitions.hpp\:Color}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Color} : {\b ENUM}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The color of a block or train car. Perrywinkle represents all colors. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v Red\:definitions.hpp}
{\xe \v definitions.hpp\:Red}
{\b {\i Red{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
}}  \par
{\xe \v Yellow\:definitions.hpp}
{\xe \v definitions.hpp\:Yellow}
{\b {\i Yellow{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
}}  \par
{\xe \v Green\:definitions.hpp}
{\xe \v definitions.hpp\:Green}
{\b {\i Green{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
}}  \par
{\xe \v Blue\:definitions.hpp}
{\xe \v definitions.hpp\:Blue}
{\b {\i Blue{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
}}  \par
{\xe \v Perrywinkle\:definitions.hpp}
{\xe \v definitions.hpp\:Perrywinkle}
{\b {\i Perrywinkle{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
}}  \par
}{
Definition at line 46 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                  : ENUM \{\par
47     Red,\par
48     Yellow,\par
49     Green,\par
50     Blue,\par
51     Perrywinkle  // essentially, no color\par
52 \};\par
}
}
{\xe \v Layer\:definitions.hpp}
{\xe \v definitions.hpp\:Layer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Layer} : {\b ENUM}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the location of a block in its stack. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v Top\:definitions.hpp}
{\xe \v definitions.hpp\:Top}
{\b {\i Top{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
}}  \par
{\xe \v Bottom\:definitions.hpp}
{\xe \v definitions.hpp\:Bottom}
{\b {\i Bottom{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
}}  \par
}{
Definition at line 57 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 57                  : ENUM \{\par
58     Top,\par
59     Bottom\par
60 \};\par
}
}
{\xe \v LogMode\:definitions.hpp}
{\xe \v definitions.hpp\:LogMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b LogMode} : {\b ENUM}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The mode in which the Log should prepare (i.e., text only or text and images). \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v Text\:definitions.hpp}
{\xe \v definitions.hpp\:Text}
{\b {\i Text{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
}}  \par
{\xe \v Multi\:definitions.hpp}
{\xe \v definitions.hpp\:Multi}
{\b {\i Multi{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
}}  \par
}{
Definition at line 66 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 66                    : ENUM \{\par
67     Text,\par
68     Multi\par
69 \};\par
}
}
{\xe \v Result\:definitions.hpp}
{\xe \v definitions.hpp\:Result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Result} : {\b ENUM}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of half blocks picked up in a stack. The integer value of the \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v NoBlocks\:definitions.hpp}
{\xe \v definitions.hpp\:NoBlocks}
{\b {\i NoBlocks{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
}}  \par
{\xe \v NoHalves\:definitions.hpp}
{\xe \v definitions.hpp\:NoHalves}
{\b {\i NoHalves{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
}}  \par
{\xe \v TwoHalves\:definitions.hpp}
{\xe \v definitions.hpp\:TwoHalves}
{\b {\i TwoHalves{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
}}  \par
{\xe \v FourHalves\:definitions.hpp}
{\xe \v definitions.hpp\:FourHalves}
{\b {\i FourHalves{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
}}  \par
}{
Definition at line 75 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 75                   : ENUM \{\par
76     NoBlocks = -1,\par
77     NoHalves = 0,\par
78     TwoHalves = 2,\par
79     FourHalves = 4\par
80 \};\par
}
}
{\xe \v Side\:definitions.hpp}
{\xe \v definitions.hpp\:Side}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Side} : {\b ENUM}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents which block to pick up when multiple blocks are visible. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v Left\:definitions.hpp}
{\xe \v definitions.hpp\:Left}
{\b {\i Left{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
}}  \par
{\xe \v Right\:definitions.hpp}
{\xe \v definitions.hpp\:Right}
{\b {\i Right{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
}}  \par
}{
Definition at line 83 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 83                 : ENUM \{\par
84     Left,\par
85     Right\par
86 \};\par
}
}
{\xe \v Size\:definitions.hpp}
{\xe \v definitions.hpp\:Size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Size} : {\b ENUM}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The block size, either 2.5" or 5". \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v Short\:definitions.hpp}
{\xe \v definitions.hpp\:Short}
{\b {\i Short{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
}}  \par
{\xe \v Long\:definitions.hpp}
{\xe \v definitions.hpp\:Long}
{\b {\i Long{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
}}  \par
}{
Definition at line 89 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 89                 : ENUM \{\par
90     Short,\par
91     Long\par
92 \};\par
}
}
{\xe \v Zone\:definitions.hpp}
{\xe \v definitions.hpp\:Zone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Zone} : {\b ENUM}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zone A, B, or C \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v A\:definitions.hpp}
{\xe \v definitions.hpp\:A}
{\b {\i A{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
}}  \par
{\xe \v B\:definitions.hpp}
{\xe \v definitions.hpp\:B}
{\b {\i B{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
}}  \par
{\xe \v C\:definitions.hpp}
{\xe \v definitions.hpp\:C}
{\b {\i C{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
}}  \par
}{
Definition at line 95 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 95                 : ENUM \{\par
96     A = 'A',\par
97     B = 'B',\par
98     C = 'C'\par
99 \};\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Grabber.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/Grabber.hpp}
{\xe \v src/Grabber.hpp}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the Grabber class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cmath>}\par
{\f2 #include <map>}\par
{\f2 #include <opencv2/highgui/highgui.hpp>}\par
{\f2 #include <opencv2/imgproc/imgproc.hpp>}\par
{\f2 #include <string>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <vector>}\par
{\f2 #include "Arm.hpp"}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "Block.hpp"}\par
{\f2 #include "Log.hpp"}\par
{\f2 #include "PiCamera.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Grabber.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Grabber_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Grabber_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChipChipArray::Grabber}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b ChipChipArray}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the Grabber class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b Grabber.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/img.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/img.cpp}
{\xe \v src/img.cpp}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to display the current camera image. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <opencv2/highgui/highgui.hpp>}\par
{\f2 #include <opencv2/imgproc/imgproc.hpp>}\par
{\f2 #include <string>}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "PiCamera.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for img.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "img_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to display the current camera image. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b img.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:img.cpp}
{\xe \v img.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program displays the current camera image. \par
}{
Definition at line 22 of file img.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22            \{\par
23     string window = "Current";\par
24     PiCamera cam;\par
25     \par
26     namedWindow(window, CV_WINDOW_NORMAL | CV_WINDOW_KEEPRATIO);\par
27 \par
28     while(true) \{\par
29         Mat image;\par
30         transpose(cam.Snap(), image);\par
31         imshow(window, image);\par
32         waitKey(10);  // has to be here :(\par
33     \}\par
34 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "img_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/jacob_alg_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/jacob_alg_test.cpp}
{\xe \v src/jacob_alg_test.cpp}
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program that tests Jacob's yellow-detection algorithm. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <opencv2/core/core.hpp>}\par
{\f2 #include <opencv2/imgproc/imgproc.hpp>}\par
{\f2 #include "PiCamera.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for jacob_alg_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "jacob__alg__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program that tests Jacob's yellow-detection algorithm. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b jacob_alg_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:jacob_alg_test.cpp}
{\xe \v jacob_alg_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program tests Jacob Laurel's algorithm for detecting yellow blocks (RGB=>YUV, HSV=>RGB). \par
}{
Definition at line 21 of file jacob_alg_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21            \{\par
22     PiCamera cam;\par
23     namedWindow("window", CV_WINDOW_NORMAL);\par
24     Mat orig = cam.Snap();\par
25     Mat yuv;\par
26     Mat fin;\par
27     cvtColor(orig, yuv, CV_BGR2YUV);\par
28     cvtColor(yuv, fin, CV_HSV2BGR);\par
29     imshow("window", fin);\par
30     waitKey(-1);\par
31 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "jacob__alg__test_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/loading_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/loading_test.cpp}
{\xe \v src/loading_test.cpp}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "Block.hpp"}\par
{\f2 #include "Grabber.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for loading_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "loading__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:loading_test.cpp}
{\xe \v loading_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program was used solely to test the Grabber class. It moves the arm and picks up blocks. \par
}{
Definition at line 19 of file loading_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19            \{\par
20     setup();\par
21     Grabber g(Zone::A, Side::Left);\par
22     g.Load();\par
23     g.Close();\par
24 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "loading__test_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Log.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/Log.hpp}
{\xe \v src/Log.hpp}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains Log class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ctime>}\par
{\f2 #include <fstream>}\par
{\f2 #include <iostream>}\par
{\f2 #include <opencv2/highgui/highgui.hpp>}\par
{\f2 #include <string>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include "definitions.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Log.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Log_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Log_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChipChipArray::Log}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b ChipChipArray}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains Log class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b Log.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/log_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/log_test.cpp}
{\xe \v src/log_test.cpp}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to test partially the Log class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <sstream>}\par
{\f2 #include <string>}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "Log.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for log_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "log__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to test partially the Log class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b log_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:log_test.cpp}
{\xe \v log_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program partially tests the Log class. \par
}{
Definition at line 18 of file log_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18            \{\par
19     Log log("logs", LogMode::Text);\par
20     log.Debug("yolo!");\par
21     log.Variable("mymom","toldme");\par
22 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "log__test_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/main.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/main.cpp}
{\xe \v src/main.cpp}
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the {\b main()} function to the whole project. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdlib>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "Servo_Position_Shell.h"}\par
{\f2 #include "Adafruit_PWMServoDriver.h"}\par
{\f2 #include <iostream>}\par
{\f2 #include "NavigationControl.h"}\par
{\f2 #include "Initialization.cpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for main.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "main_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b READTHINKDO}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b startstatus}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b startroboth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b stoproboth}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b track}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b navigationbusy}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b cleartonavigate}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b cleartoload}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b cleartounload}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b robotismoving}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b whereistherobot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b loadcounter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b unloadcounter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b loadtheblocks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b unloadtheblocks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b giveitasec}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b startloadingthread}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the {\b main()} function to the whole project. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Nickolas Neely \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 1. February 2016, 8:20 AM \par
}}{
Definition in file {\b main.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v READTHINKDO\:main.cpp}
{\xe \v main.cpp\:READTHINKDO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define READTHINKDO}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 27 of file main.cpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b main()} project program function. \par
}{
Definition at line 51 of file main.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 51            \{\par
52 \par
53 initialization();\par
54 #ifdef READTHINKDO\par
55 /*Track selection initialization will allow track select until start condition is true*/\par
56 while(1)\{\par
57     while(track == 1 && startroboth == 0)\{\par
58         startstatus = digitalRead(0);\par
59         track = digitalRead(1);\par
60         cout<<endl<<"I am in left track mode";\par
61         if(startstatus == 1)\{\par
62             startroboth = 1;\par
63         \}\par
64         \par
65         /* RUN MODE FOR LEFT TRACK GAME START!*/\par
66         while(startroboth == 1 && stoproboth == 0)\{\par
67  //READ for left track\par
68             \par
69             startstatus = digitalRead(0);\par
70             navigationbusy = digitalRead(2);\par
71             \par
72 //THINK for left track\par
73             \par
74             //clearance to do an action;\par
75             if(cleartoload == 1 || cleartounload == 1)\{\par
76                 cleartonavigate = 0;\par
77             \}\par
78             else if(cleartonavigate == 1 || cleartounload == 1)\{\par
79                 cleartoload = 0;\par
80             \}\par
81             else if(cleartonavigate == 1 || cleartoload == 1)\{\par
82                 cleartounload = 0;\par
83             \}\par
84 \par
85             \par
86             // latch to figure out robot position in sequence\par
87             if(navigationbusy == 1 && robotismoving == 0)\{\par
88                 robotismoving = 1;\par
89                 whereistherobot++;\par
90             \}else if(navigationbusy == 0 && robotismoving == 1)\{\par
91                 robotismoving = 0;\par
92             \}\par
93             \par
94             //working actions \par
95             if(whereistherobot > 0 && whereistherobot <=4 && navigationbusy == 0)\{\par
96                 cleartoload = 1;\par
97             \}else if(whereistherobot > 0 && whereistherobot <=4 && navigationbusy == 1)\{\par
98                 cleartoload = 0;\par
99             \}else if(whereistherobot == 5 && navigationbusy == 0)\{\par
100                 cleartounload = 1;\par
101             \}else if(whereistherobot == 5 && navigationbusy == 1)\{\par
102                 cleartounload = 0;\par
103             \}\par
104             \par
105 \par
106             //controls load action timing\par
107             if(cleartoload == 1 && loadcounter < 2000)\{\par
108                 loadtheblocks = 1;\par
109                 loadcounter ++;\par
110                 startloadingthread = 1;\par
111                 \par
112             \}else if(loadcounter >= 2000)\{\par
113                 cleartoload = 0;\par
114                 loadcounter = 1;\par
115             \}\par
116             \par
117             //controls the unload action timing\par
118             if(cleartounload ==1 && unloadcounter < 150)\{\par
119                 unloadcounter++;\par
120                 unloadtheblocks = 1;\par
121             \}else if(loadcounter >= 150)\{\par
122                 cleartounload = 0;\par
123                 unloadcounter = 1;\par
124                 unloadtheblocks = 0;\par
125             \}\par
126             \par
127 //DO for the left track\par
128             \par
129             //Navigate to next position in sequence\par
130             if(cleartounload == 0 && cleartoload == 0 && robotismoving == 0)\{\par
131                 digitalWrite(3,HIGH);  \par
132             \}else if(robotismoving == 1)\{\par
133                 digitalWrite(3,LOW);\par
134             \}\par
135             \par
136             //load blocks \par
137             if(loadtheblocks ==1)\{\par
138                 pthread_t andrewthread;\par
139                 pthread_create(&andrewthread,NULL,grabCall,NULL);\par
140                 \par
141                 loadtheblocks =0;\par
142                 \par
143             \}\par
144             \par
145             // unload the blocks\par
146             if(unloadtheblocks ==1 && unloadcounter < 100)\{\par
147                 setServoPosition(Servo(10),90);\par
148                 setServoPosition(Servo(11),90);\par
149                 setServoPosition(Servo(12),90);\par
150                 setServoPosition(Servo(13),90);\par
151             \}else if(unloadtheblocks == 1 && unloadcounter >= 100 && unloadcounter <140)\{\par
152                 setServoPosition(Servo(10),0);\par
153                 setServoPosition(Servo(11),0);\par
154                 setServoPosition(Servo(12),0);\par
155                 setServoPosition(Servo(13),0);\par
156             \}else if(unloadtheblocks == 1 && unloadcounter >= 140)\{\par
157                 setServoPosition(Servo(10),-1);\par
158                 setServoPosition(Servo(11),-1);\par
159                 setServoPosition(Servo(12),-1);\par
160                 setServoPosition(Servo(13),-1);\par
161             \}\par
162             \par
163             cout<<endl<<"I am in run mode of left track";\par
164             \par
165             /* stops Robot if ever hit on a RTD loop*/\par
166             if(startstatus == 0)\{\par
167                 digitalWrite(3,LOW);\par
168                 cout<<endl<<"Halting all function stop engaged after a start";\par
169                 giveitasec++;\par
170                 if(giveitasec >= 50)\{\par
171                     stoproboth = 1;\par
172                     giveitasec = 0;\par
173                 \}\par
174             \}\par
175             cout<<endl<<"The current position of robot is:"<<whereistherobot<<endl;\par
176             \par
177             // delay for 20 milliseconds per loop\par
178             usleep(20000);\par
179 \par
180 \par
181         \}\par
182     \}\par
183     /*Track selection initialization will allow track select until start condition is true*/\par
184     while(track == 0 && startroboth ==0)\{\par
185         startstatus = digitalRead(0);\par
186         track = digitalRead(1);\par
187         if(startstatus == 1)\{\par
188             startroboth = 1;\par
189         \}\par
190         cout<<endl<<"I am in right track mode.";\par
191         cout<<"Not yet implemented. Danger. Danger. Danger.";\par
192     \}\par
193 \}\par
194 #endif\par
195 #ifdef SWITCHTEST\par
196     int cat;\par
197     int dog;\par
198     wiringPiSetup();\par
199     while(1)\{\par
200         \par
201         //test each pin if needed for setup and checking\par
202         /*\par
203         cout<<endl;\par
204         cout<<"Input a pin to check:"<<endl;\par
205         cin>>dog;\par
206         cat =digitalRead(dog);\par
207         cout<<"I am reading:"<<cat<<endl;\par
208         */\par
209         \par
210         if(digitalRead(0)==1)\{\par
211             cout<<"Heavy is in stop or idle mode."<<endl;\par
212            \par
213         \}else if(digitalRead(0)==0)\{\par
214             cout<<"Heavy is in run mode!"<<endl;\par
215         \}\par
216         if(digitalRead(1)==1)\{\par
217             cout<<"Heavy is set for left track."<<endl;\par
218         \}else if(digitalRead(1)==0)\{\par
219             cout<<"Heavy is set for right track."<<endl;\par
220         \}\par
221         \par
222         cout<<endl<<"Press enter to continue";\par
223         cin.ignore();\par
224     \}\par
225 #endif\par
226     \par
227 #ifdef ARMTEST\par
228     \par
229     Servo whichservo;\par
230     int tmpServo = -1;\par
231     int position;\par
232     setup();\par
233     while(1)\{\par
234         cout<<endl;\par
235         cout<<"Pick a servo to use: BASE_TURN = 0, BASE_TILT = 1, ELBOW = 2, WRIST_TILT = 3,";\par
236         cout<<endl<<"WRIST_PAN = 4, GRIP_LEFT = 5, GRIP_RIGHT = 6";\par
237         cout<<endl;\par
238         cin>>tmpServo;\par
239         if(tmpServo > 6 || tmpServo < 0)\{\par
240             cout<<"Please choose again:"<<endl;\par
241             continue;\par
242         \}\par
243         whichservo = (Servo)tmpServo;\par
244         cout<<endl;\par
245         cout<<"Pick a position (set position to -1 to disengage servo and set pwm to 0):";\par
246         cin>>position;\par
247         cout<<endl;\par
248         setServoPosition(whichservo,position);\par
249         \par
250     \}\par
251 #endif     \par
252 \par
253 #ifdef NAVTEST\par
254 \par
255     int cat = 0;\par
256     pinMode(2,INPUT);\par
257     while(1)\{\par
258         cout<<"High or Low?:"<<endl;\par
259         cin>>cat;\par
260         digitalWrite(3,cat);\par
261         cout<<endl;\par
262         if(digitalRead(2)==1)\{\par
263             cout<<"I am getting a high from Micah"<<endl;\par
264            \par
265         \}else if(digitalRead(2)==0)\{\par
266             cout<<"I am getting a low from Micah"<<endl;\par
267         \}\par
268     \} \par
269     cin.ignore();\par
270 \par
271     \par
272     \par
273 #endif\par
274 \par
275 #ifdef UNLOADTEST\par
276     \par
277     Servo whichservo;\par
278     int tmpServo = -1;\par
279     int position;\par
280 \par
281     setup();\par
282     while(1)\{\par
283         /*\par
284         cout<<endl;\par
285         cout<<"Pick a servo to use: ";\par
286         cout<<endl<<"UNLOAD_1= 10, UNLOAD_2 = 11, UNLOAD_3 = 12, UNLOAD_4 = 13";\par
287         cout<<endl;\par
288         cin>>tmpServo;\par
289         if(tmpServo < 10 || tmpServo > 14)\{\par
290             cout<<"Please choose again:"<<endl;\par
291             continue;\par
292         \}\par
293         whichservo = (Servo)tmpServo;\par
294         */ \par
295         cout<<endl;\par
296         cout<<"Pick a position (set position to -1 to disengage servo and set pwm to 0):";\par
297         cin>>position;\par
298         cout<<endl;\par
299         //setServoPosition((Servo)tmpServo,position); \par
300         setServoPosition((Servo)10,position);\par
301         setServoPosition((Servo)11,position);\par
302         setServoPosition((Servo)12,position);\par
303         setServoPosition((Servo)13,position);\par
304         \par
305     \}\par
306     \par
307 #endif\par
308     return 0;\par
309 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "main_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cleartoload\:main.cpp}
{\xe \v main.cpp\:cleartoload}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int cleartoload}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file main.cpp.}\par
}
{\xe \v cleartonavigate\:main.cpp}
{\xe \v main.cpp\:cleartonavigate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int cleartonavigate}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file main.cpp.}\par
}
{\xe \v cleartounload\:main.cpp}
{\xe \v main.cpp\:cleartounload}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int cleartounload}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file main.cpp.}\par
}
{\xe \v giveitasec\:main.cpp}
{\xe \v main.cpp\:giveitasec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int giveitasec}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 45 of file main.cpp.}\par
}
{\xe \v loadcounter\:main.cpp}
{\xe \v main.cpp\:loadcounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int loadcounter}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 41 of file main.cpp.}\par
}
{\xe \v loadtheblocks\:main.cpp}
{\xe \v main.cpp\:loadtheblocks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int loadtheblocks}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 43 of file main.cpp.}\par
}
{\xe \v navigationbusy\:main.cpp}
{\xe \v main.cpp\:navigationbusy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int navigationbusy}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file main.cpp.}\par
}
{\xe \v robotismoving\:main.cpp}
{\xe \v main.cpp\:robotismoving}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int robotismoving}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file main.cpp.}\par
}
{\xe \v startloadingthread\:main.cpp}
{\xe \v main.cpp\:startloadingthread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int startloadingthread}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 46 of file main.cpp.}\par
}
{\xe \v startroboth\:main.cpp}
{\xe \v main.cpp\:startroboth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int startroboth}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file main.cpp.}\par
}
{\xe \v startstatus\:main.cpp}
{\xe \v main.cpp\:startstatus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int startstatus}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file main.cpp.}\par
}
{\xe \v stoproboth\:main.cpp}
{\xe \v main.cpp\:stoproboth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int stoproboth}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file main.cpp.}\par
}
{\xe \v track\:main.cpp}
{\xe \v main.cpp\:track}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int track}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file main.cpp.}\par
}
{\xe \v unloadcounter\:main.cpp}
{\xe \v main.cpp\:unloadcounter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int unloadcounter}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 42 of file main.cpp.}\par
}
{\xe \v unloadtheblocks\:main.cpp}
{\xe \v main.cpp\:unloadtheblocks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int unloadtheblocks}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file main.cpp.}\par
}
{\xe \v whereistherobot\:main.cpp}
{\xe \v main.cpp\:whereistherobot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int whereistherobot}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file main.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/NavigationControl.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/NavigationControl.cpp}
{\xe \v src/NavigationControl.cpp}
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the navigation control function definitions. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "NavigationControl.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for NavigationControl.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "NavigationControl_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b navigationSetup} ({\b uint8_t} navigation_add)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b commandNavigation} ({\b uint8_t} navigationcommand)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b navigationcmd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b nav_fd}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the navigation control function definitions. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Nickolas Neely \par
}}{
Definition in file {\b NavigationControl.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v commandNavigation\:NavigationControl.cpp}
{\xe \v NavigationControl.cpp\:commandNavigation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void commandNavigation ({\b uint8_t} {\i navigationcommand})}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file NavigationControl.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                                                  \{\par
20     uint8_t data = navigationcommand;\par
21     wiringPiI2CWrite(nav_fd, data);\par
22 \}\par
}
}
{\xe \v navigationSetup\:NavigationControl.cpp}
{\xe \v NavigationControl.cpp\:navigationSetup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void navigationSetup ({\b uint8_t} {\i navigation_add})}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file NavigationControl.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14                                             \{\par
15     nav_fd=wiringPiI2CSetup(navigation_add);\par
16     \par
17 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v nav_fd\:NavigationControl.cpp}
{\xe \v NavigationControl.cpp\:nav_fd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} nav_fd}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file NavigationControl.cpp.}\par
}
{\xe \v navigationcmd\:NavigationControl.cpp}
{\xe \v NavigationControl.cpp\:navigationcmd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} navigationcmd}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file NavigationControl.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/NavigationControl.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/NavigationControl.h}
{\xe \v src/NavigationControl.h}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the function definitions for navigation control. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <wiringPi.h>}\par
{\f2 #include <wiringPiI2C.h>}\par
{\f2 #include <ctype.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for NavigationControl.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "NavigationControl_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "NavigationControl_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b uint8_t}\~ unsigned char\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b navigationSetup} ({\b uint8_t} navigation_add)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b commandNavigation} ({\b uint8_t} navigationcommand)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the function definitions for navigation control. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Nickolas Neely \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 22. Febrary 2016, 12:00 PM \par
}}{
Definition in file {\b NavigationControl.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v uint8_t\:NavigationControl.h}
{\xe \v NavigationControl.h\:uint8_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define uint8_t\~ unsigned char}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file NavigationControl.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v commandNavigation\:NavigationControl.h}
{\xe \v NavigationControl.h\:commandNavigation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void commandNavigation ({\b uint8_t} {\i navigationcommand})}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file NavigationControl.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                                                  \{\par
20     uint8_t data = navigationcommand;\par
21     wiringPiI2CWrite(nav_fd, data);\par
22 \}\par
}
}
{\xe \v navigationSetup\:NavigationControl.h}
{\xe \v NavigationControl.h\:navigationSetup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void navigationSetup ({\b uint8_t} {\i navigation_add})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file NavigationControl.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14                                             \{\par
15     nav_fd=wiringPiI2CSetup(navigation_add);\par
16     \par
17 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/net_qr_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/net_qr_test.cpp}
{\xe \v src/net_qr_test.cpp}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test program for reading QR codes. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <opencv2/highgui/highgui.hpp>}\par
{\f2 #include <opencv2/imgproc/imgproc.hpp>}\par
{\f2 #include <zbar.h>}\par
{\f2 #include <iostream>}\par
{\f2 #include "PiCamera.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for net_qr_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net__qr__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test program for reading QR codes. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Michael Young \par
Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b net_qr_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:net_qr_test.cpp}
{\xe \v net_qr_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char * {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a (modified) test program written by Michael Young ({\f2 https://github.com/ayoungprogrammer/WebcamCodeScanner}). It was modified to work with the Raspicam. \par
}{
Definition at line 25 of file net_qr_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26 \{\par
27     PiCamera cam; // open the video camera no. 0\par
28     ImageScanner scanner;  \par
29     scanner.set_config(ZBAR_NONE, ZBAR_CFG_ENABLE, 1);  \par
30 \par
31     namedWindow("MyVideo",CV_WINDOW_AUTOSIZE); //create a window called "MyVideo"\par
32 \par
33     while (1)\par
34     \{\par
35         Mat frame = cam.Snap();\par
36         Mat grey;\par
37         cvtColor(frame,grey,CV_BGR2GRAY);\par
38 \par
39         int width = frame.cols;  \par
40         int height = frame.rows;  \par
41         uchar *raw = (uchar *)grey.data;  \par
42         // wrap image data  \par
43         zbar::Image image(width, height, "Y800", raw, width * height);  \par
44         // scan the image for barcodes  \par
45         int n = scanner.scan(image);  \par
46         // extract results  \par
47         for(Image::SymbolIterator symbol = image.symbol_begin();  \par
48                 symbol != image.symbol_end();  \par
49                 ++symbol) \{  \par
50             vector<Point> vp;  \par
51             // do something useful with results  \par
52             cout << "decoded " << symbol->get_type_name()  << " symbol \\"" << symbol->get_data() << '"' <<" "<< endl;  \par
53             int n = symbol->get_location_size();  \par
54             for(int i=0;i<n;i++)\{  \par
55                 vp.push_back(Point(symbol->get_location_x(i),symbol->get_location_y(i))); \par
56             \}  \par
57             RotatedRect r = minAreaRect(vp);  \par
58             Point2f pts[4];  \par
59             r.points(pts);  \par
60             for(int i=0;i<4;i++)\{  \par
61                 line(frame,pts[i],pts[(i+1)%4],Scalar(255,0,0),3);  \par
62             \}  \par
63         \}  \par
64 \par
65         imshow("MyVideo", frame); //show the frame in "MyVideo" window\par
66 \par
67         if (waitKey(30) == 27) //wait for 'esc' key press for 30ms. If 'esc' key is pressed, break loop\par
68         \{\par
69             cout << "esc key is pressed by user" << endl;\par
70             break; \par
71         \}\par
72     \}\par
73     return 0;\par
74 \par
75 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "net__qr__test_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/old_cv_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/old_cv_test.cpp}
{\xe \v src/old_cv_test.cpp}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains old test program for the RaspiCam_Cv class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <core/core.hpp>}\par
{\f2 #include <highgui/highgui.hpp>}\par
{\f2 #include <iostream>}\par
{\f2 #include "raspicam_cv.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for old_cv_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "old__cv__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains old test program for the RaspiCam_Cv class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b old_cv_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:old_cv_test.cpp}
{\xe \v old_cv_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program was used to test the raspicam wrapper for OpenCV before implementing it in a more projet-friendly form as the PiCamera class. \par
}{
Definition at line 17 of file old_cv_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17            \{\par
18     cv::namedWindow("Test", CV_WINDOW_AUTOSIZE);\par
19 \par
20     raspicam::RaspiCam_Cv cam;\par
21     cv::Mat image;\par
22 \par
23     bool s = cam.set(CV_CAP_PROP_FORMAT, CV_16UC3);\par
24     bool o = cam.open();\par
25 \par
26     while(true) \{\par
27         cam.grab();\par
28         cam.retrieve(image);\par
29         cv::imshow("Test", image);\par
30         cv::waitKey(1000);\par
31 \par
32     \}\par
33 \par
34     cam.release();\par
35 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/PiCamera.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/PiCamera.hpp}
{\xe \v src/PiCamera.hpp}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains PiCamera class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <opencv2/core/core.hpp>}\par
{\f2 #include <opencv2/highgui/highgui.hpp>}\par
{\f2 #include <raspicam/raspicam_cv.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "definitions.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for PiCamera.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "PiCamera_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "PiCamera_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChipChipArray::PiCamera}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b ChipChipArray}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains PiCamera class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b PiCamera.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/qr_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/qr_test.cpp}
{\xe \v src/qr_test.cpp}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test program for {\b ScanQR()} function. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <opencv2/core/core.hpp>}\par
{\f2 #include <opencv2/highgui/highgui.hpp>}\par
{\f2 #include <string>}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "PiCamera.hpp"}\par
{\f2 #include "ScanQR.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for qr_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "qr__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains test program for {\b ScanQR()} function. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b qr_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:qr_test.cpp}
{\xe \v qr_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program tests the {\b ScanQR()} function in terms of reading QR codes (not moving the arm). \par
}{
Definition at line 22 of file qr_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22            \{\par
23     while(true) \{\par
24         Color color = ScanQR();\par
25         std::string colstr;\par
26 \par
27         switch(color) \{\par
28             case Color::Red:\par
29                 colstr = "RED";\par
30                 break;\par
31 \par
32             case Color::Yellow:\par
33                 colstr = "YELLOW";\par
34                 break;\par
35 \par
36             case Color::Green:\par
37                 colstr = "GREEN";\par
38                 break;\par
39 \par
40             case Color::Blue:\par
41                 colstr = "BLUE";\par
42                 break;\par
43 \par
44         \}\par
45 \par
46         std::cout << colstr << std::endl;\par
47     \}\par
48 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "qr__test_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/ScanQR.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/ScanQR.hpp}
{\xe \v src/ScanQR.hpp}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains {\b ScanQR()} function. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include <opencv2/highgui/highgui.hpp>}\par
{\f2 #include <opencv2/imgproc/imgproc.hpp>}\par
{\f2 #include <zbar.h>}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "Log.hpp"}\par
{\f2 #include "PiCamera.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ScanQR.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ScanQR_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ScanQR_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b ChipChipArray}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Color} {\b ChipChipArray::ScanQR} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8} {\b ChipChipArray::qrInvokeCount} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Log {\b ChipChipArray::scanQrLog} ("logs/ScanQR", LogMode::Multi)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains {\b ScanQR()} function. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b ScanQR.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Servo_Position_Shell.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/Servo_Position_Shell.cpp}
{\xe \v src/Servo_Position_Shell.cpp}
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
COntains the function definitions for the servo position shell. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <wiringPi.h>}\par
{\f2 #include "Adafruit_PWMServoDriver.cpp"}\par
{\f2 #include <iostream>}\par
{\f2 #include "Servo_Position_Shell.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Servo_Position_Shell.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8cpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SERVOMIN}\~ 150\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SERVOMAX}\~ 600\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setup} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setServoPulse} ({\b uint8_t} {\b servo_num}, double pulse)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setServoPosition} ({\b Servo} whichservo, int position)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Adafruit_PWMServoDriver} {\b pwm} = {\b Adafruit_PWMServoDriver}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8_t} {\b servo_num}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
COntains the function definitions for the servo position shell. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Nickolas Neely \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 8. February 2016, 12:05 PM \par
}}{
Definition in file {\b Servo_Position_Shell.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v SERVOMAX\:Servo_Position_Shell.cpp}
{\xe \v Servo_Position_Shell.cpp\:SERVOMAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SERVOMAX\~ 600}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file Servo_Position_Shell.cpp.}\par
}
{\xe \v SERVOMIN\:Servo_Position_Shell.cpp}
{\xe \v Servo_Position_Shell.cpp\:SERVOMIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SERVOMIN\~ 150}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file Servo_Position_Shell.cpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v setServoPosition\:Servo_Position_Shell.cpp}
{\xe \v Servo_Position_Shell.cpp\:setServoPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setServoPosition ({\b Servo} {\i whichservo}, int {\i position})}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Desc: This function sets which servo to use using whichservo and what position out of 180 degrees for each servo (with limits). {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i whichservo} \cell }{which servo would you like to use on the board \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{what position do you want to set the servo selected at \cell }
{\row }
}
}{
Definition at line 71 of file Servo_Position_Shell.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 71                                                       \{\par
72     // works for servo 0, 3, 4\par
73     double dividedconstant = 180.0;\par
74     double highservo = 2.4;\par
75     double lowservo = 0.6;\par
76     // To fix the magical digital servo on LIFT 1\par
77     double highservoweird = 1.9;\par
78     double lowservoweird = 0.6;\par
79     // To compensate for the bent servo spline on LIFT 2\par
80     double highservospline = 2.25;\par
81     double lowservospline = 0.6;\par
82     // works for servo 1, 2\par
83     double digitalservohigh = 2.45;\par
84     double digitalservolow = 0.9;\par
85     // left gripper servo 5\par
86     double gripleftopen = 2.2;\par
87     double gripleftclose = 1.3;\par
88     // right gripper servo 6\par
89     double griprightopen = 2.2;\par
90     double griprightclose = 1.3;\par
91     double pulse;\par
92 \par
93     switch (whichservo) \{\par
94 \par
95             // BASE TURN\par
96         case 0:\par
97         \{\par
98             if (position == -1) \{\par
99                 pulse = 0.0;\par
100             \}else if (position < 0)\{\par
101                 position = 20;\par
102                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
103             \}else if (position > 179)\{\par
104                 position = 179;\par
105                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
106             \}else\{\par
107                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
108             \}\par
109             \par
110         \}\par
111 \par
112             break;\par
113 \par
114             // BASE TILT\par
115         case 1:\par
116         \{\par
117             \par
118             \par
119             if (position == -1) \{\par
120                 pulse = 0.0;\par
121             \} else if (position < 90)\{\par
122                 position = 90;\par
123                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
124             \} else if (position > 172)\{\par
125                 position = 172;\par
126                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
127             \} else \{\par
128                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
129             \}\par
130         \}\par
131             break;\par
132 \par
133             // ELBOW\par
134         case 2:\par
135         \{\par
136             if (position == -1) \{\par
137                 pulse = 0.0;\par
138             \} else if (position < 43)\{\par
139                 position = 43;\par
140                 pulse = ((((digitalservohigh - digitalservolow) / dividedconstant)*((double) position)) + digitalservolow);\par
141             \} else if (position > 179)\{\par
142                 position = 179;\par
143                 pulse = ((((digitalservohigh - digitalservolow) / dividedconstant)*((double) position)) + digitalservolow);\par
144             \} else \{\par
145                 pulse = ((((digitalservohigh - digitalservolow) / dividedconstant)*((double) position)) + digitalservolow);\par
146             \}\par
147         \}\par
148             break;\par
149 \par
150             // WRIST TURN\par
151         case 3:\par
152         \{\par
153             if (position == -1) \{\par
154                 pulse = 0.0;\par
155             \} else \{\par
156                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
157             \}\par
158         \}\par
159             break;\par
160 \par
161             // WRIST PAN\par
162         case 4:\par
163         \{\par
164             if (position == -1) \{\par
165                 pulse = 0.0;\par
166             \} else if (position < 0)\{\par
167                 position = 0;\par
168                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
169             \} else if (position > 180)\{\par
170                 position = 180;\par
171                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
172             \} else \{\par
173                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
174             \}\par
175         \}\par
176             break;\par
177 \par
178             // GRIP LEFT\par
179         case 5:\par
180         \{\par
181             if (position == -1) \{\par
182                 pulse = 0.0;\par
183             \} else if(position < 0)\{\par
184                 position = 0;\par
185                 pulse = ((((griprightopen - griprightclose) / dividedconstant)*((double) position)) + griprightclose);\par
186             \}else if(position > 90)\{\par
187                 position = 90;\par
188                 pulse = ((((griprightopen - griprightclose) / dividedconstant)*((double) position)) + griprightclose);\par
189             \} else \{\par
190                 pulse = ((((gripleftopen - gripleftclose) / dividedconstant)*((double) position)) + gripleftclose);\par
191             \}\par
192         \}\par
193             break;\par
194 \par
195             // GRIP RIGHT\par
196         case 6:\par
197         \{\par
198             if (position == -1) \{\par
199                 pulse = 0.0;\par
200             \} else if(position < 90)\{\par
201                 position = 90;\par
202                 pulse = ((((griprightopen - griprightclose) / dividedconstant)*((double) position)) + griprightclose);\par
203             \} else if(position > 180)\{\par
204                 position = 180;\par
205                 pulse = ((((griprightopen - griprightclose) / dividedconstant)*((double) position)) + griprightclose);\par
206             \}else\{\par
207                 pulse = ((((griprightopen - griprightclose) / dividedconstant)*((double) position)) + griprightclose);\par
208             \}\par
209         \}\par
210             break;\par
211 \par
212             // Michael Yellow Gate\par
213         case 7:\par
214         \{\par
215             if (position == -1) \{\par
216                 pulse = 0.0;\par
217             \} else if(position < 0)\{\par
218                 position = 0;\par
219                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
220             \} else if(position > 90)\{\par
221                 position = 90;\par
222                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
223             \} else \{\par
224                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
225             \}\par
226         \}\par
227             break;\par
228 \par
229             // Michael Green Gate\par
230         case 8:\par
231         \{\par
232             if (position == -1) \{\par
233                 pulse = 0.0;\par
234             \} else if(position < 0)\{\par
235                 position = 0;\par
236                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
237             \} else if(position > 90)\{\par
238                 position = 90;\par
239                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
240             \} else \{\par
241                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
242             \}\par
243         \}\par
244             break;\par
245 \par
246             // Michael Blue Gate\par
247         case 9:\par
248         \{\par
249             if (position == -1) \{\par
250                 pulse = 0.0;\par
251             \} else if(position < 0)\{\par
252                 position = 0;\par
253                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
254             \} else if(position > 90)\{\par
255                 position = 90;\par
256                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
257             \} else \{\par
258                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
259             \}\par
260         \}\par
261             break;\par
262 \par
263             // Michael Lift 1\par
264         case 10:\par
265         \{\par
266             if (position == -1) \{\par
267                 pulse = 0.0;\par
268             \} else if(position < 0)\{\par
269                 position = 0;\par
270                 pulse = ((((highservoweird - lowservoweird) / dividedconstant)*((double) position)) + lowservoweird);\par
271             \} else if(position > 105)\{\par
272                 position = 105;\par
273                 pulse = ((((highservoweird - lowservoweird) / dividedconstant)*((double) position)) + lowservoweird);\par
274             \} else \{\par
275                 pulse = ((((highservoweird - lowservoweird) / dividedconstant)*((double) position)) + lowservoweird);\par
276             \}\par
277         \}\par
278             break;\par
279 \par
280             //Michael Lift 2\par
281         case 11:\par
282         \{\par
283             if (position == -1) \{\par
284                 pulse = 0.0;\par
285             \} else if(position < 0)\{\par
286                 position = 0;\par
287                 pulse = ((((highservospline - lowservospline) / dividedconstant)*((double) position)) + lowservospline);\par
288             \} else if(position > 105)\{\par
289                 position = 105;\par
290                 pulse = ((((highservospline - lowservospline) / dividedconstant)*((double) position)) + lowservospline);\par
291             \} else \{\par
292                 pulse = ((((highservospline - lowservospline) / dividedconstant)*((double) position)) + lowservospline);\par
293             \}\par
294         \}\par
295             break;\par
296 \par
297             //Michael lift 3\par
298         case 12:\par
299         \{\par
300             if (position == -1) \{\par
301                 pulse = 0.0;\par
302             \} else if(position < 0)\{\par
303                 position = 0;\par
304                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
305             \} else if(position > 105)\{\par
306                 position = 105;\par
307                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
308             \} else \{\par
309                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
310             \}\par
311         \}\par
312             break;\par
313 \par
314             // Michael lift 4\par
315         case 13:\par
316         \{\par
317             if (position == -1) \{\par
318                 pulse = 0.0;\par
319             \} else if(position < 0)\{\par
320                 position = 0;\par
321                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
322             \} else if(position > 105)\{\par
323                 position = 105;\par
324                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
325             \} else \{\par
326                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
327             \}\par
328         \}\par
329             break;\par
330 \par
331             // Michael RED GATE\par
332         case 14:\par
333         \{\par
334             if (position == -1) \{\par
335                 pulse = 0.0;\par
336             \} else if(position < 0)\{\par
337                 position = 0;\par
338                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
339             \} else if(position > 105)\{\par
340                 position = 105;\par
341                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
342             \} else \{\par
343                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
344             \}\par
345         \}\par
346             break;\par
347     \}\par
348     setServoPulse(whichservo, pulse);\par
349 \par
350 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8cpp_abd2cd3c2e36d42a2178a6f2fd12af905_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8cpp_abd2cd3c2e36d42a2178a6f2fd12af905_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v setServoPulse\:Servo_Position_Shell.cpp}
{\xe \v Servo_Position_Shell.cpp\:setServoPulse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setServoPulse ({\b uint8_t} {\i n}, double {\i pulse})}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Desc: This function sets which servo to use and what pulse to set that servos pwm to. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i n} \cell }{which servo on the breakout board am I calling. Starting with 0. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pulse} \cell }{what is the pulse length (in micro seconds) the pwm of the servo is set to. \cell }
{\row }
}
}{
Definition at line 50 of file Servo_Position_Shell.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50                                                     \{\par
51     double pulselength;\par
52 \par
53     pulselength = 1000000; // 1,000,000 us per second\par
54     pulselength /= 60; // 60 Hz\par
55     //cout << pulselength << " us per period" << endl;\par
56     pulselength /= 4096; // 12 bits of resolution\par
57     //cout << pulselength << "us per bit" << endl;\par
58     pulse *= 1000;\par
59     pulse /= pulselength;\par
60     //cout << (uint16_t) pulse << endl;\par
61     pwm.setPWM(servo_num, 0, (uint16_t) pulse);\par
62     //cout << endl;\par
63 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8cpp_a7f07c548295f3696f8881f0c9de708b1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8cpp_a7f07c548295f3696f8881f0c9de708b1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v setup\:Servo_Position_Shell.cpp}
{\xe \v Servo_Position_Shell.cpp\:setup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setup ()}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Desc: This function sets up the breakout board communication with I2C using Adafruits_PWMServoDriver.cpp and to set the frequency of the servos to 60Hz. \par
}{
Definition at line 41 of file Servo_Position_Shell.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41              \{\par
42     //cout << "Testing Servos" << endl;\par
43     pwm.begin();\par
44     pwm.setPWMFreq(60.0); // Analog servos run at ~60 Hz updates\par
45 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8cpp_a4fc01d736fe50cf5b977f755b675f11d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8cpp_a4fc01d736fe50cf5b977f755b675f11d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v pwm\:Servo_Position_Shell.cpp}
{\xe \v Servo_Position_Shell.cpp\:pwm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Adafruit_PWMServoDriver} pwm = {\b Adafruit_PWMServoDriver}()}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file Servo_Position_Shell.cpp.}\par
}
{\xe \v servo_num\:Servo_Position_Shell.cpp}
{\xe \v Servo_Position_Shell.cpp\:servo_num}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8_t} servo_num}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file Servo_Position_Shell.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Servo_Position_Shell.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/Servo_Position_Shell.h}
{\xe \v src/Servo_Position_Shell.h}
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the function prototypes for the servo position shell. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <wiringPi.h>}\par
{\f2 #include "Adafruit_PWMServoDriver.h"}\par
{\f2 #include <iostream>}\par
{\f2 #include <ctype.h>}\par
{\f2 #include <cstdint>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Servo_Position_Shell.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Servo} \{ {\b BASE_TURN} = 0, 
{\b BASE_TILT} = 1, 
{\b ELBOW} = 2, 
{\b WRIST_TILT} = 3, 
{\b WRIST_PAN} = 4, 
{\b GRIP_RIGHT} = 5, 
{\b GRIP_LEFT} = 6, 
{\b GATE_1} = 7, 
{\b GATE_2} = 8, 
{\b GATE_3} = 9, 
{\b LIFT_1} = 10, 
{\b LIFT_2} = 11, 
{\b LIFT_3} = 12, 
{\b LIFT_4} = 13, 
{\b GATE_4} = 14
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setServoPulse} ({\b uint8_t} n, double pulse)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setup} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setServoPosition} ({\b Servo} whichservo, int position)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the function prototypes for the servo position shell. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Nickolas Neely \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 8. February 2016, 12:05 PM \par
}}{
Definition in file {\b Servo_Position_Shell.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v Servo\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:Servo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Servo}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines each of the servos on the robot. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v BASE_TURN\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:BASE_TURN}
{\b {\i BASE_TURN{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
}}  \par
{\xe \v BASE_TILT\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:BASE_TILT}
{\b {\i BASE_TILT{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
}}  \par
{\xe \v ELBOW\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:ELBOW}
{\b {\i ELBOW{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
}}  \par
{\xe \v WRIST_TILT\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:WRIST_TILT}
{\b {\i WRIST_TILT{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
}}  \par
{\xe \v WRIST_PAN\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:WRIST_PAN}
{\b {\i WRIST_PAN{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
}}  \par
{\xe \v GRIP_RIGHT\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:GRIP_RIGHT}
{\b {\i GRIP_RIGHT{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
}}  \par
{\xe \v GRIP_LEFT\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:GRIP_LEFT}
{\b {\i GRIP_LEFT{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
}}  \par
{\xe \v GATE_1\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:GATE_1}
{\b {\i GATE_1{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
}}  \par
{\xe \v GATE_2\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:GATE_2}
{\b {\i GATE_2{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
}}  \par
{\xe \v GATE_3\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:GATE_3}
{\b {\i GATE_3{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
}}  \par
{\xe \v LIFT_1\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:LIFT_1}
{\b {\i LIFT_1{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
}}  \par
{\xe \v LIFT_2\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:LIFT_2}
{\b {\i LIFT_2{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
}}  \par
{\xe \v LIFT_3\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:LIFT_3}
{\b {\i LIFT_3{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
}}  \par
{\xe \v LIFT_4\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:LIFT_4}
{\b {\i LIFT_4{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
}}  \par
{\xe \v GATE_4\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:GATE_4}
{\b {\i GATE_4{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
}}  \par
}{
Definition at line 28 of file Servo_Position_Shell.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28           \{\par
29     BASE_TURN = 0,\par
30     BASE_TILT = 1,\par
31     ELBOW = 2,\par
32     WRIST_TILT = 3,\par
33     WRIST_PAN = 4,\par
34     GRIP_RIGHT = 5,\par
35     GRIP_LEFT = 6,\par
36     GATE_1 = 7,\par
37     GATE_2 = 8,\par
38     GATE_3 = 9,\par
39     LIFT_1 = 10,\par
40     LIFT_2 = 11,\par
41     LIFT_3 = 12,\par
42     LIFT_4 = 13,\par
43     GATE_4 = 14\par
44 \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v setServoPosition\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:setServoPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setServoPosition ({\b Servo} {\i whichservo}, int {\i position})}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Desc: This function sets which servo to use using whichservo and what position out of 180 degrees for each servo (with limits). {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i whichservo} \cell }{which servo would you like to use on the board \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{what position do you want to set the servo selected at \cell }
{\row }
}
}{
Definition at line 71 of file Servo_Position_Shell.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 71                                                       \{\par
72     // works for servo 0, 3, 4\par
73     double dividedconstant = 180.0;\par
74     double highservo = 2.4;\par
75     double lowservo = 0.6;\par
76     // To fix the magical digital servo on LIFT 1\par
77     double highservoweird = 1.9;\par
78     double lowservoweird = 0.6;\par
79     // To compensate for the bent servo spline on LIFT 2\par
80     double highservospline = 2.25;\par
81     double lowservospline = 0.6;\par
82     // works for servo 1, 2\par
83     double digitalservohigh = 2.45;\par
84     double digitalservolow = 0.9;\par
85     // left gripper servo 5\par
86     double gripleftopen = 2.2;\par
87     double gripleftclose = 1.3;\par
88     // right gripper servo 6\par
89     double griprightopen = 2.2;\par
90     double griprightclose = 1.3;\par
91     double pulse;\par
92 \par
93     switch (whichservo) \{\par
94 \par
95             // BASE TURN\par
96         case 0:\par
97         \{\par
98             if (position == -1) \{\par
99                 pulse = 0.0;\par
100             \}else if (position < 0)\{\par
101                 position = 20;\par
102                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
103             \}else if (position > 179)\{\par
104                 position = 179;\par
105                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
106             \}else\{\par
107                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
108             \}\par
109             \par
110         \}\par
111 \par
112             break;\par
113 \par
114             // BASE TILT\par
115         case 1:\par
116         \{\par
117             \par
118             \par
119             if (position == -1) \{\par
120                 pulse = 0.0;\par
121             \} else if (position < 90)\{\par
122                 position = 90;\par
123                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
124             \} else if (position > 172)\{\par
125                 position = 172;\par
126                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
127             \} else \{\par
128                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
129             \}\par
130         \}\par
131             break;\par
132 \par
133             // ELBOW\par
134         case 2:\par
135         \{\par
136             if (position == -1) \{\par
137                 pulse = 0.0;\par
138             \} else if (position < 43)\{\par
139                 position = 43;\par
140                 pulse = ((((digitalservohigh - digitalservolow) / dividedconstant)*((double) position)) + digitalservolow);\par
141             \} else if (position > 179)\{\par
142                 position = 179;\par
143                 pulse = ((((digitalservohigh - digitalservolow) / dividedconstant)*((double) position)) + digitalservolow);\par
144             \} else \{\par
145                 pulse = ((((digitalservohigh - digitalservolow) / dividedconstant)*((double) position)) + digitalservolow);\par
146             \}\par
147         \}\par
148             break;\par
149 \par
150             // WRIST TURN\par
151         case 3:\par
152         \{\par
153             if (position == -1) \{\par
154                 pulse = 0.0;\par
155             \} else \{\par
156                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
157             \}\par
158         \}\par
159             break;\par
160 \par
161             // WRIST PAN\par
162         case 4:\par
163         \{\par
164             if (position == -1) \{\par
165                 pulse = 0.0;\par
166             \} else if (position < 0)\{\par
167                 position = 0;\par
168                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
169             \} else if (position > 180)\{\par
170                 position = 180;\par
171                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
172             \} else \{\par
173                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
174             \}\par
175         \}\par
176             break;\par
177 \par
178             // GRIP LEFT\par
179         case 5:\par
180         \{\par
181             if (position == -1) \{\par
182                 pulse = 0.0;\par
183             \} else if(position < 0)\{\par
184                 position = 0;\par
185                 pulse = ((((griprightopen - griprightclose) / dividedconstant)*((double) position)) + griprightclose);\par
186             \}else if(position > 90)\{\par
187                 position = 90;\par
188                 pulse = ((((griprightopen - griprightclose) / dividedconstant)*((double) position)) + griprightclose);\par
189             \} else \{\par
190                 pulse = ((((gripleftopen - gripleftclose) / dividedconstant)*((double) position)) + gripleftclose);\par
191             \}\par
192         \}\par
193             break;\par
194 \par
195             // GRIP RIGHT\par
196         case 6:\par
197         \{\par
198             if (position == -1) \{\par
199                 pulse = 0.0;\par
200             \} else if(position < 90)\{\par
201                 position = 90;\par
202                 pulse = ((((griprightopen - griprightclose) / dividedconstant)*((double) position)) + griprightclose);\par
203             \} else if(position > 180)\{\par
204                 position = 180;\par
205                 pulse = ((((griprightopen - griprightclose) / dividedconstant)*((double) position)) + griprightclose);\par
206             \}else\{\par
207                 pulse = ((((griprightopen - griprightclose) / dividedconstant)*((double) position)) + griprightclose);\par
208             \}\par
209         \}\par
210             break;\par
211 \par
212             // Michael Yellow Gate\par
213         case 7:\par
214         \{\par
215             if (position == -1) \{\par
216                 pulse = 0.0;\par
217             \} else if(position < 0)\{\par
218                 position = 0;\par
219                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
220             \} else if(position > 90)\{\par
221                 position = 90;\par
222                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
223             \} else \{\par
224                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
225             \}\par
226         \}\par
227             break;\par
228 \par
229             // Michael Green Gate\par
230         case 8:\par
231         \{\par
232             if (position == -1) \{\par
233                 pulse = 0.0;\par
234             \} else if(position < 0)\{\par
235                 position = 0;\par
236                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
237             \} else if(position > 90)\{\par
238                 position = 90;\par
239                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
240             \} else \{\par
241                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
242             \}\par
243         \}\par
244             break;\par
245 \par
246             // Michael Blue Gate\par
247         case 9:\par
248         \{\par
249             if (position == -1) \{\par
250                 pulse = 0.0;\par
251             \} else if(position < 0)\{\par
252                 position = 0;\par
253                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
254             \} else if(position > 90)\{\par
255                 position = 90;\par
256                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
257             \} else \{\par
258                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
259             \}\par
260         \}\par
261             break;\par
262 \par
263             // Michael Lift 1\par
264         case 10:\par
265         \{\par
266             if (position == -1) \{\par
267                 pulse = 0.0;\par
268             \} else if(position < 0)\{\par
269                 position = 0;\par
270                 pulse = ((((highservoweird - lowservoweird) / dividedconstant)*((double) position)) + lowservoweird);\par
271             \} else if(position > 105)\{\par
272                 position = 105;\par
273                 pulse = ((((highservoweird - lowservoweird) / dividedconstant)*((double) position)) + lowservoweird);\par
274             \} else \{\par
275                 pulse = ((((highservoweird - lowservoweird) / dividedconstant)*((double) position)) + lowservoweird);\par
276             \}\par
277         \}\par
278             break;\par
279 \par
280             //Michael Lift 2\par
281         case 11:\par
282         \{\par
283             if (position == -1) \{\par
284                 pulse = 0.0;\par
285             \} else if(position < 0)\{\par
286                 position = 0;\par
287                 pulse = ((((highservospline - lowservospline) / dividedconstant)*((double) position)) + lowservospline);\par
288             \} else if(position > 105)\{\par
289                 position = 105;\par
290                 pulse = ((((highservospline - lowservospline) / dividedconstant)*((double) position)) + lowservospline);\par
291             \} else \{\par
292                 pulse = ((((highservospline - lowservospline) / dividedconstant)*((double) position)) + lowservospline);\par
293             \}\par
294         \}\par
295             break;\par
296 \par
297             //Michael lift 3\par
298         case 12:\par
299         \{\par
300             if (position == -1) \{\par
301                 pulse = 0.0;\par
302             \} else if(position < 0)\{\par
303                 position = 0;\par
304                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
305             \} else if(position > 105)\{\par
306                 position = 105;\par
307                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
308             \} else \{\par
309                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
310             \}\par
311         \}\par
312             break;\par
313 \par
314             // Michael lift 4\par
315         case 13:\par
316         \{\par
317             if (position == -1) \{\par
318                 pulse = 0.0;\par
319             \} else if(position < 0)\{\par
320                 position = 0;\par
321                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
322             \} else if(position > 105)\{\par
323                 position = 105;\par
324                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
325             \} else \{\par
326                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
327             \}\par
328         \}\par
329             break;\par
330 \par
331             // Michael RED GATE\par
332         case 14:\par
333         \{\par
334             if (position == -1) \{\par
335                 pulse = 0.0;\par
336             \} else if(position < 0)\{\par
337                 position = 0;\par
338                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
339             \} else if(position > 105)\{\par
340                 position = 105;\par
341                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
342             \} else \{\par
343                 pulse = ((((highservo - lowservo) / dividedconstant)*((double) position)) + lowservo);\par
344             \}\par
345         \}\par
346             break;\par
347     \}\par
348     setServoPulse(whichservo, pulse);\par
349 \par
350 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8h_abd2cd3c2e36d42a2178a6f2fd12af905_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8h_abd2cd3c2e36d42a2178a6f2fd12af905_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v setServoPulse\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:setServoPulse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setServoPulse ({\b uint8_t} {\i n}, double {\i pulse})}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Desc: This function sets which servo to use and what pulse to set that servos pwm to. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i n} \cell }{which servo on the breakout board am I calling. Starting with 0. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i pulse} \cell }{what is the pulse length (in micro seconds) the pwm of the servo is set to. \cell }
{\row }
}
}{
Definition at line 50 of file Servo_Position_Shell.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50                                                     \{\par
51     double pulselength;\par
52 \par
53     pulselength = 1000000; // 1,000,000 us per second\par
54     pulselength /= 60; // 60 Hz\par
55     //cout << pulselength << " us per period" << endl;\par
56     pulselength /= 4096; // 12 bits of resolution\par
57     //cout << pulselength << "us per bit" << endl;\par
58     pulse *= 1000;\par
59     pulse /= pulselength;\par
60     //cout << (uint16_t) pulse << endl;\par
61     pwm.setPWM(servo_num, 0, (uint16_t) pulse);\par
62     //cout << endl;\par
63 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8h_a323a36dcf89ccad28f3ed2312e26ed8a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8h_a323a36dcf89ccad28f3ed2312e26ed8a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v setup\:Servo_Position_Shell.h}
{\xe \v Servo_Position_Shell.h\:setup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setup ()}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Desc: This function sets up the breakout board communication with I2C using Adafruits_PWMServoDriver.cpp and to set the frequency of the servos to 60Hz. \par
}{
Definition at line 41 of file Servo_Position_Shell.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41              \{\par
42     //cout << "Testing Servos" << endl;\par
43     pwm.begin();\par
44     pwm.setPWMFreq(60.0); // Analog servos run at ~60 Hz updates\par
45 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8h_a4fc01d736fe50cf5b977f755b675f11d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Servo__Position__Shell_8h_a4fc01d736fe50cf5b977f755b675f11d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}